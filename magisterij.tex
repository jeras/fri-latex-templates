%*****************************************************************
%   Vzorec za pisanje diplomskega dela,
%   ki vsebuje navodila za izdelavo diplomskega dela
%
%   UNIVERZA V LJUBLJANI
%   Fakulteta za računalništvo in informatiko
%
%   Pripravila: Peter.Peer@fri.uni-lj.si
%               Franc.Solina@fri.uni-lj.si
%*****************************************************************

\documentclass[12pt,a4paper,openany,twoside]{book}

%Uporabljeni paketi
\usepackage[utf8]{inputenc}
\usepackage{cmap}
\usepackage{type1ec}
\usepackage[T1]{fontenc}
\usepackage{graphicx,epsfig}
\usepackage[slovene]{babel}
\usepackage{cite}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{url}
\usepackage[pdftex,colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black,pagebackref]{hyperref}
\usepackage[top=2cm, bottom=3cm, inner=3cm, outer=2cm]{geometry}

%Nastavitev glave in repa strani
\pagestyle{myheadings}

% stil odstavkov
\setlength{\parindent}{0cm}
\setlength{\parskip}{5mm plus2mm minus2mm}

\input{cc}

%********************************************
% kratice, simboli
\newcommand{\abbrlabel}[1]{\makebox[3cm][l]{\textbf{#1}\ \dotfill}}
\newenvironment{abbreviations}{\begin{list}{}{\renewcommand{\makelabel}{\abbrlabel}}}{\end{list}}
%********************************************

\begin{document}

%********************************************
% platnica
\thispagestyle{empty} 
\begin{center}
             {\large UNIVERZA V LJUBLJANI\\
                     FAKULTETA ZA RAČUNALNIŠTVO IN INFORMATIKO\\}
\vspace{3cm} {\large Iztok Jeras}\\
\vspace{2cm} {\large \textbf{Predslike 2D celičnih avtomatov}}\\
\vspace{2cm} {MAGISTERSKO DELO\\ NA UNIVERZITETNEM ŠTUDIJU}\\
\vfill       {\Large Ljubljana, 2016}
\end{center}
\newpage
\ \thispagestyle{empty}
\newpage
%********************************************

%********************************************
% stran 1 med uvodnimi listi
\thispagestyle{empty} 
\begin{center}
             {\large UNIVERZA V LJUBLJANI\\
                     FAKULTETA ZA RAČUNALNIŠTVO IN INFORMATIKO\\}
\vspace{3cm} {\large Iztok Jeras}\\
\vspace{2cm} {\large \textbf{Predslike 2D celičnih avtomatov}}\\
\vspace{2cm} {MAGISTERSKO DELO\\ NA UNIVERZITETNEM ŠTUDIJU}\\
\vspace{2cm} {\Large Mentor: prof. dr. Branko Šter}
\vfill       {\Large Ljubljana, 2016}
\end{center}
\newpage
\ \thispagestyle{empty}
\newpage
%********************************************

%********************************************
% stran 7 med uvodnimi listi

\chapter*{Zahvala}

\thispagestyle{empty}

Na tem mestu se diplomant zahvali vsem, ki so kakorkoli pripomogli k uspešni izvedbi diplomskega dela.


\newpage

%********************************************
% stran 8 med uvodnimi listi je prazna pri dvostranskem tiskanju
\ \thispagestyle{empty}

\newpage

\renewcommand\thepage{} 
\tableofcontents 
\renewcommand\thepage{\arabic{page}}

\thispagestyle{empty}

%********************************************

\chapter*{Seznam uporabljenih kratic in simbolov}

\thispagestyle{empty}

% simboli

\begin{abbreviations}
\item[1D] eno dimenzionalen
\item[2D] dvo dimenzionalen
\item[3D] tri dimenzionalen
\item[CA] celični avtomat
\item[GoL] Conway's Game of Life (Conwayeva igra življenja)
\item[GoE] Garden of Eden (stanje brez predslik)
\item[trid] okolica CA sestevljena iz treh celic
\item[quad] okolica CA sestevljena iz štirih celic \(M_x=M_y=2\)

\item[\(C\)] poljubna konstanta
\item[\(S\)] množica nabora stanj celice
\item[\(|S|\)] število možnih stanj celice
\item[\(c\)] stanje posamezne celice (celoštevilska vrednost)
\item[\(c_{x,y}\)] vrednost celice na položaju \([x,y]\) znotraj 2D polja celic
\item[\(c^t\)] vrednost celice v sedanjosti
\item[\(c^{t+1}\)] vrednost celice v prihodnosti (eden korak)
\item[\(N_x\)] velikost 2D polja celic v dimenziji X
\item[\(N_y\)] velikost 2D polja celic v dimenziji Y
\item[\(N\)] število celic v 2D polju
\item[\(M_x\)] velikost 2D okolice celice v dimenziji X
\item[\(M_y\)] velikost 2D okolice celice v dimenziji Y
\item[\(m\)] število celic v 2D okolici
\item[\(n\)] stanje okolice posamezne celice (celoštevilska vrednost)
\item[\(n_{x,y}\)] vrednost okolice celice na položaju \([x,y]\) znotraj 2D polja celic
\item[\(n^{t-1}\)] vrednost celice v preteklosti (eden korak)
\item[\(n^t\)] vrednost okolice celice v sedanjosti
\item[\(f\)] tranzicijska funkcija
\item[\(f^{-1}\)] obratna tranzicijska funkcija
\item[\(o_x\)] prekrivanje okolic v dimenziji X
\item[\(o_y\)] prekrivanje okolic v dimenziji Y
\item[\(o_{xy}\)] prekrivanje okolic v diagonalni smeri
\end{abbreviations}

%\cleardoublepage

\clearpage{\pagestyle{empty}\cleardoublepage}

%********************************************
%zacno se glavni listi, ki so numerirani z arabskimi stevilkami

\setcounter{page}{1}
\pagenumbering{arabic}

\chapter*{Povzetek}

\addcontentsline{toc}{chapter}{Povzetek}

Medtem, ko je računanje predslik 1D celičnih avtomatov dobro raziskan in
podrobno dokumentiran problem, je to področje pri 2D celičnih avtomatih manj
raziskano. To magistrsko delo poizkuša aplicirati metode razvite za 1D avtomate
na 2D problem. Prikazan je algoritem, ki omogoča štetje in izpis predslik.
Razvit je bil s pomočjo grafičnega modela, mreže predslik, 
ki omogoča uporabo teorije grafov pri izračunih in dokazih.

\vspace{1.3cm}
\noindent
{\large \bf Ključne besede:}

\vspace{0.5cm}
\noindent
celični avtomati, predslike, procesna zahtevnost, reverzibilnost, rajski vrt, Conwayeva igra življenja, trid, quad


\chapter*{Abstract}

\addcontentsline{toc}{chapter}{Abstract}

While computing preimages of 1D cellular automata is a well researched and
documented problem, for 2D cellular automata there is less research available.
This masters thesis attempts to apply methods developed for 1D automata to the
2D problem. An algorithm is shown, which can count and list preimages.
It was developed with the help of a graphical representation, which enables using graph theory for computation and proofs.

\vspace{1.3cm}
\noindent
{\large \bf Key words:}

\vspace{0.5cm}
\noindent
cellular automata, preimages, ataviser, computational complexity, reversibility, Garden of Eden, Conway's Game of Life, trid, quad


%********************************************

\chapter{Uvod}

\section{CA kakor model vesolja}

Ker lahko vsak univerzalen sistem modelira vsak drugi univerzalen sistem, lahko predpostavimo,
da lahko z univerzalnimi CA modeliramo vesolje. Samo modeliranje vesolja
je še izven našega dosega, poizkuša pa se vsaj približati teorijo CA in teoretično fiziko.
S strani informacijske teorije in termodinamike je predvsem zanimiv model gravitacije
kakor entropijske sile (Entropic gravity \cite{Verlinde2010}), ki predpostavlja, da je
3D vesolje projekcija procesov, ki se odvijajo na 2D ploskvi. Z druge strani pa CA omogočajo
opazovanje abstraktnega kopiranja informacij (replikacija) in evolucije \cite{Salzberg2004}.

\section{Informacijska dinamika}

Informacijsko dinamiko CA se najpogosteje opisuje samo kakor reverzibilno ali ireverzibilno,
obstaja tudi nekaj člankov, ki opazujejo entropijo sistema.
Pogosto je tudi opazovanje dinamike delcev pri GoL in elementarnem pravilu 110.
Ne obstaja pa še splošna teorija dinamike informacij v CA.
V svojem članku \cite{JerasDobnikar2007} in prispevkih na konferencah \cite{DBLP:conf/iccS/JerasD06, DBLP:conf/automata/Jeras08},
sem grafično upodobil predslike trenutnega stanja za 1D problem.
Iz upodobitve je videti, da se ponekod izgubi več informacije kakor drugod,
kar kaže na možnost izpeljave kvalitativne in kvantitativne teorije dinamike informacij;
žal se ta možnost še ni udejanila. Podobno je možno grafično upodobiti predslike 2D CA,
ter iz grafov sklepati o izgubi informacij v 2D CA.

\section{Problem predslik 2D CA}

Najbolje teoretično raziskan 2D CA je GoL (Game of Life ali slovensko igra življenja).
Ogromno truda je bilo vloženega v raziskovanje delcev in njihove dinamike. S pomočjo
osnovnih gradnikov, je mogoče skonstruirati kompleksnejše sisteme, med katerimi so
najzanimivejši turingov stroj \cite{Rendell2001} in univerzalni konstruktor \cite{Greene2013}.

Delci so dejansko atraktorji v razvoju CA na končni periodični mreži (thorus).
Pri 1D CA se algoritmi za iskanje predslik uporabljajo za določitev atraktorjevega korita \cite{Wuensche1992}.
V vsakem CA, ki ni lokalno injektiven se pojavljajo stanja brez predslik imenovana GoE
(Garden of Eden ali rajski vrt) \cite{Moore1962, Myhill1963}.
Pomensko so GoE nasprotje delcev, saj se nahajajo kar
najdlje od atraktorja na robu korita. GoE stanja prav tako kakor delci privlačijo raziskovalce,
čeprav v manjši meri kakor delci.

Največ raziskav s področja predslik GoL je bilo opravljenih ravno s ciljem iskanja GoE stanj.
S stališča algoritma za štetje predslik je GoE stanje tako, ki nima nobene predslike.
Algoritem za štetje predslik je možno pretvoriti v algoritem za preverjanje ali je stanje GoE,
tako da se operacije nad celimi števili pretvori v logične operacije nad Boolovimi stanji.

\section{Algoritmi za iskanje predslik}

Raziskave algoritmov sem se lotil s predpostavko, da je možno opraviti štetje s zahtevnostjo,
ki je linearno odvisna od velikosti problema \( O(N) \)  (\(N\) je število opazovanih celic).
Čeprav je to možno pri 1D problemu, se izkaže, da 2D problem ni tako preprost.
Predstavljeni so primeri iz katerih je razvidno,
da algoritem z linearno zahtevnostjo ne more pravilno opisati vseh situacij.
Zahtevnost opisanega algoritma sicer raste eksponentno z velikostjo ene
od dimenzij CA polja \( O(C^N) \), je pa možno, da obstaja algoritem z nižjo kompleksnostjo.

Pomembno vlogo pri razvoju opisanega algoritma ima mreža predslik.
To je grafična upodobitev problema, katere cilj je lažje razumevanje problema in rešitev.
Osnova za oblikovanje mreže predslik so De Bruijn-ovi diagrami.
Paulina Léon in Genaro Martínez \cite{PaulinaGenaro2016}
poizkušata aplicirati De Bruijn-ove diagrame na 2D CA,
doslej je bilo to orodje uporabljeno le na 1D problemih.
Točneje, opazujeta dva CA:'Game of Life' in 'Diffusion rule',
s poudarkom na opazovanju stabilnih delcev.
Sam uporabljam De Bruijn-ovi diagrame nekoliko drugače,
in jih tudi drugače grafično upodabljam.
Posamezen De Bruijn-ov diagram postane mreža predslik ene celice.
Mreže posameznih celic se nato povezujejo,
tako da na koncu opisujejo celotno polje celic.

Doslej sem že razvil napredne algoritme za izračun predslik 1D CA \cite{JerasDobnikar2007}.
Skozi zgodovino so taki algoritmi napredovali, tako da je padala njihova
procesna zahtevnost in opisna/implementacijska zahtevnost.
\begin{enumerate}[noitemsep,nolistsep]
 \item 'brute force' algoritmi \( O(C^N) \)
 \item improvizirani algoritmi
 \item zasnove matematičnega modela
 \item optimalni algoritmi \( O(N) \)
\end{enumerate}
Iskanje predslik 2D CA je trenutno nekje med improvizacijo in matematičnim modelom.

Opisan algoritem na koncu primerjam z ostalimi doslej znanimi algoritmi.
Čeprav s stališča procesne zahtevnosti ne prinaša želenega napredka,
pa to, da temelji na pregledni grafični upodobitvi daje upanje,
da bojo razne optimizacije razvidne bodočim raziskovalcem.

Celični avtomat GoL je definiran z Moorovo okolico velikosti \(3 \times 3\).
Tako velika okolica ima z \(9\) celicami \(2^9=512\) možnih stanj,
zaradi česar so ilustracije mreže predslik velike in nepregledne.
Splošno je znana manjša von Neumannova okolica velikosti \(3 \times 3\) v obliki križa iz \(5\) celic.
Z \(2^5=32\) stanji bi bile ilustracije bolj pregledne, ampak obstajajo tudi okolice z manj celicami.
Toffoli \cite{Toffoli2008} je leta 2008 spodbudil raziskovalce k iskanju univerzalnosti za CA
z okolicama trid (tri celice na heksagonalnem polju) in quad (štiri celice na kvadratnem polju).
Powley \cite{Powley2008} hitro dokaže obstoj univerzalnega avtomata z okolico trid,
tako da ustvari avtomat, ki lahko s pomočjo določenega začetnega stanja
simulira 1D elementarni celični avtomat, na primer pravilo 110.
Sam sem obe okolici poznal že prej. Zame je njuna najboljša lastnost majhen nabor stanj okolice,
\(2^4=16\) za quad in \(2^3=8\) za trid. Za primere je bil uporabljen quad,
saj so diagrami na kvadratni mreži bolj enostavni in pregledni, kakor diagrami na heksagonalni mreži.

Algoritem je implementiran kot računalniški program v jeziku C \cite{Jeras2016-algirithm}.
Knjižnica GMP je uporabljena za zapis celih števil večjih od 64 bitov.
Poleg samega algoritma za štetje in izpis predslik sem pripravil tudi
orodje za simulacijo binarnega CA z okolico quad \cite{Jeras2016-quad}
in orodje za prikaz poljubne mreže predslik \cite{Jeras2016-network}.
Obe orodji se lahko zažene kar v internetnem brskalniku.

V slikah je uporabljena izometrična projekcija,
saj je za potrebe analize je osnovnemu 2D polju dodana tretja dimenzija,
ki opisuje prostor predslik (mreža predslik).

\chapter{Definicija 2D CA}

Predstavljena definicija 2D CA je enostavna in manj formalna
v primerjavi z definicijo 1D CA v podobnih prispevkih.
Bolj formalna definicija ni potrebna, saj se opisani problemi za 2D CA,
še ne povezujejo z drugimi vejami matematike toliko kakor 1D CA.

Osnovni element 2D CA je celica kakor del polja celic.
Vsaka celica ima diskretno vrednost \(c\) iz nabora stanj celice \(S\).
Stanja so običajno kar oštevilčena.

\begin{equation}
c \in S
\quad \textrm{in} \quad
S = \{ 0, 1, 2, {\lvert S \rvert} -1 \}
\end{equation}

Mreža polja je lahko pravokotna, šestkotna ali celo kvazikristalna, tukaj se
bomo omejili na pravokotno mrežo. Na splošno je velikost polja lahko neskončna,
bolj običajna pa so končna polja definira kakor pravokotnik velikosti \(N_x \times N_y\)
in skupno število celic v končnem polju je \(N=\lvert N_x \times N_y \rvert\).

Prihodnje stanje neke celice \(c_{x,y}\) (na položaju \((x,y)\)
je odvisno od trenutnega stanja pripadajoče okolice \(n_{x,y}\) (slika \ref{neighborhood}).
Podobno se bom tudi pri obliki okolice omejil na pravokotnik velikosti \(M_x \times M_y\).
Število celic v okolici je \(m=\lvert M_x \times M_y \rvert\).
Na voljo je \({\lvert S \rvert}^m\) možnih okolic.

\begin{equation}
n \in S^m
\quad \textrm{in} \quad
S^m = \{ 0, 1, 2, {\lvert S \rvert}^m -1 \}
\end{equation}

Prostorski odnos med okolico in celico v prihodnjem stanju avtomata, ki jo ta okolica določa,
ni podrobno definiran. Običajno se smatra, da je celica v sredini okolice, ampak za opisani algoritem to ni
nujno pomembno.

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood,width=16cm}}
\caption[Velikost okolice.]{Celica \(c_{x,y}\) in pripadajoča okolica \(n_{x,y}\) z dimenzijama \(M_x=M_y=3\).}
\label{neighborhood}
\end{figure}

Preslikava sedanje okolice \(n_{x,y}^{t}\) v prihodnjo istoležno celico \(c_{x,y}^{t+1}\) je definiran
s tranzicijsko funkcijo \(f\), ki vsaki vrednosti okolice pripiše vrednost celice.

\begin{equation}
c_{x,y}^{t+1} = f(n_{x,y}^{t})
\end{equation}

Za potrebe iskanja predslik je zanimiva obratna funkcija \(f^{-1}\), ki ob
podanem stanju trenutne celice \(c_{x,y}^{t}\) vrne množico okolic,
ki se preslikajo v to vrednost.

\begin{equation}
f^{-1}(c^{t}) = \{ n^{t-1} \in S^m \ \arrowvert \ f(n^{t-1}) = c^{t} \}
\end{equation}

Dodaten pogoj za predslike polja celic je, da se morajo okolice sosednjih celic
ujemati povsod, kjer se prekrivajo.

Tranzicijsko funkcijo je možno definirati s pravilom.
Pravilo \(r\) je celo število v \(S\)-iškem številskem sestavu,
kjer so cifre zaporedje vrednosti celic za vsako od \(|S|^m\) možnih okolic.
Vseh pravil je na voljo \(|S|^{|S|^m}\).
\begin{equation}
r = \sum_{n=0}^{n=|S|^m} |S|^n \cdot f(n)
\end{equation}
\begin{equation}
r \in \{0, 1, \dots |S|^{|S|^m}-1\}
\end{equation}

Podana konstrukcija mreže predslik in algoritem za izračun predslik omogočata uporabo
bolj splošne definicije, kjer je za vsako celico definiran lasten nabor predslik \( n^{t-1} \in S^m \),
ki je neodvisen od stanja celice. Ta posplošitev je uporabljena za konstrukcijo umetnih
mrež predslik, ki poudarjajo konkretne probleme, ki definirajo kompleksnost algoritma.

Za dano polje celic velikosti \(N_x \times N_y\) in z odprtimi robovi,
je možno izračunati prihodnje stanje polja velikosti \((N_x-(M_x-1)) \times (N_y-(M_y-1))\).
V primeru, če so robovi polja ciklično zaprti (polje v obliki thorusa),
je pa polje prihodnjega stanja enako veliko kakor polje sedanjega.
Podobno velja za računanje predslik, za sedanje polje velikosti \(N_x \times N_y\)
je za odprte robove velikost polja predslik \((N_x+(M_x-1)) \times (N_y+(M_y-1))\).
Za ciklične robove pa sta velikosti enaki.

\chapter{Konstrukcija mreže predslik}

Mreža predslik je grafični konstrukt, ki omogoča upodobitev posameznih pojmov
iz definicije CA, kakor ločene grafične elemente. Odnosi med
temi elementi definirajo pravila na katerih se gradijo algoritmi za iskanje
predslik.

\section{De Bruijnov diagram}

Osnovani element grafične upodobitve je De Bruijinov diagram. V osnovi ta obravnava
ciklične premike končnih zaporedij simbolov, ter njihovo prekrivanje. Vozlišča v
diagramu so vsa možna končna zaporedja, povezave med njimi pa definirajo kako se
ta zaporedja prekrivajo med seboj.

Pri 1D CA se problem neposredno preslika na De Bruijinov graf. McIntosh
in njegova skupina uporabljajo za analizo te De Bruijinove grafe neposredno. Sam sem pa
razvil modificiran graf, kjer so vozlišča podvojena, in gredo poti vedno od originala
proti dvojniku. To omogoča veriženje grafov, in razširitev osnovnega De Bruijinovega
grafa, ki opisuje okolico ene celice, v verižen graf, ki opisuje verigo celic.

Za potrebe opisa 2D celičnih avtomatov, je bila elementom
De Bruijinovega grafa dodana nova dimenzija. Povezave med vozliči se spremenijo
v ploskve, in vozlišča se spremenijo v robove ploskev.
Elementi celičnega avtomata, ki se preslikajo v graf so:
\begin{itemize}[noitemsep,nolistsep]
\item nabor vseh možnih okolic celice postane nabor vseh ploskev (slika \ref{neighborhood_surfaces})
\item nabor prekrivanj okolic v smeri 2D dimenzij (slika \ref{overlap_dimension_quad}) postane nabor povezav
\item nabor prekrivanj okolic v diagonalni smeri (slika \ref{overlap_diagonal_quad}) postane nabor vozlišč
\end{itemize}

Elemente celičnega avtomata, kakor okolice in prekrivanja okolic je potrebno indeksirati,
tako da se lahko vsakemu elementu pripiše unikatna števna vrednost.
Vsaki okolici je pripisana zaporedna vrednost, ki je konstruirana kakor \(m\) mestno število
v \(S\)-iškem številskem sistemu (za podane primere dvojiški).
Cifre si sledijo od spodaj levo do zgoraj desno znotraj okolice
(sliki \ref{neighborhood_index_moore} in \ref{neighborhood_index_quad}).

\begin{equation}
n = \sum_{x,y} |S|^{y N_x + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
n \in \{0, 1, \dots |S|^{N_x N_y}-1\}
\end{equation}

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood_index_moore,width=14cm}}
\caption[Indeksiranje okolice \(3 \times 3\).]{Indeksiranje okolice celice z dimenzijama \(M_x=M_y=3\).}
\label{neighborhood_index_moore}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood_index_quad,width=12cm}}
\caption[Indeksiranje okolice \(2 \times 2\).]{Indeksiranje okolice celice z dimenzijama \(M_x=M_y=2\).}
\label{neighborhood_index_quad}
\end{figure}

Celice se v smeri dimenzije X prekrivajo za ploskev velikosti \((M_x-1) \times M_y\) (sliki \ref{overlap_dimension_moore} in \ref{overlap_dimension_quad}).
To ob indeksiranju da nabor:
\begin{equation}
o_x = \sum_{x,y} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_x \in \{0, 1, \dots |S|^{(M_x-1)N_y}-1\}
\end{equation}

Celice se v smeri dimenzije Y prekrivajo za ploskev velikosti \(M_x \times (M_y-1)\) (sliki \ref{overlap_dimension_moore} in \ref{overlap_dimension_quad}).
To ob indeksiranju da nabor:
\begin{equation}
o_y = \sum_{x,y} |S|^{y M_x + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_y \in \{0, 1, \dots |S|^{M_x(N_y-1)}-1\}
\end{equation}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_dimension_moore,width=10cm}}
\caption[Prekrivaje okolic \(3 \times 3\) v smeri dimenzij X in Y.]
{Prekrivanje okolic sosednjih celic v smeri dimenzij X in Y, za velikost okolice \(M_x=M_y=3\).
Okolice se prekrivajo v 6 celicah od 9.}
\label{overlap_dimension_moore}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_dimension_quad,width=10cm}}
\caption[Prekrivaje okolic \(2 \times 2\) v smeri dimenzij X in Y.]
{Prekrivanje okolic sosednjih celic v smeri dimenzij X in Y, za velikost okolice \(M_x=M_y=2\).
Okolice se prekrivajo v 2 celicah od 4.}
\label{overlap_dimension_quad}
\end{figure}

Celice se v diagonalni smeri prekrivajo za ploskev velikosti \((M_x-1) \times (M_y-1)\) (sliki \ref{overlap_diagonal_moore} in \ref{overlap_diagonal_quad}).
To ob indeksiranju da nabor:
\begin{equation}
o_{xy} = \sum_{x,y} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_{xy} \in \{0, 1, \dots |S|^{(M_x-1)(N_y-1)}-1\}
\end{equation}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_diagonal_moore,width=10cm}}
\caption[Prekrivanje okolic \(3 \times 3\) - diagonalno.]
{Prekrivanje okolic sosednjih celic v diagonalni smeri, za velikost okolice \(M_x=M_y=3\).
Okolice se prekrivajo v 4 celicah od 9.}
\label{overlap_diagonal_moore}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_diagonal_quad,width=10cm}}
\caption[Prekrivanje okolic \(2 \times 2\) - diagonalno.]
{Prekrivanje okolic sosednjih celic v diagonalni smeri, za velikost okolice \(M_x=M_y=2\).
Okolice se prekrivajo v eni celici od 9.}
\label{overlap_diagonal_quad}
\end{figure}

Nastali graf (slika \ref{network_single}) ima poleg vozlišč in povezav med njimi tudi ploskve.
Ploskve bi v teoriji grafov opisali kakor zanke v grafu, z dodano omejitvijo,
da mora vsako vozlišče ali povezava v zanki pripadati drugemu prekrivanju okolic.

\begin{figure}[htb]
\centerline{\psfig{figure=network_single,width=5cm}}
\caption[Mreža ene celice.]{Mreža ene celice za binarni CA z okolico quad \(M_x=M_y=2\).}
\label{network_single}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood_surfaces,width=16cm}}
\caption[Nabor ploskev.]{Nabor ploskev za vse možne okolice za binarni CA z okolico quad \(M_x=M_y=2\).}
\label{neighborhood_surfaces}
\end{figure}

\section{Mreža}

Diagrame, ki opisujejo preteklost posamezne celice, je možno sestaviti v mrežo,
ki opisuje polje več celic. Nabor predslik celotnega polja je ekvivalenten naboru
vseh \textit{zveznih} ploskev, ki prekrivajo celotno polje in, ki jih je možno sestaviti iz
naborov ploskev diagramov posameznih celic.

Preslikava iz zvezne ploskve v mreži predslik v konfiguracijo polja celic predslike je enolična.
Najlažje je razumeti preslikavo za okolico velikosti \(3 \times 3\),
od vsakega odseka ploskve za posamezno celico se vzame centralno celico,
na koncu pa se doda še za eno celico širok rob okoli celotne ploskve.

Podani primeri uporabljajo binarni CA s quad okolico.
Za ta CA je velikost diagonalnega prekrivanja okolic ena sama celica (slika \ref{overlap_diagonal_quad}),
posledično ima nabor vozlišč le dve vrednosti, ki neposredno predstavljajo
vrednosti celic v predsliki (slika \ref{network_array}).
Nabor okolic/ploskev pa obsega 16 kombinacij (slika \ref{neighborhood_surfaces}).

Razširitev diagrama ene celice v mrežo lahko dokažemo z indukcijo.
Dokazati želimo, da je neka konfiguracija celic predslika dane sedanjosti
\textit{če in samo če} je ta ekvivalentna zvezni ploskvi v mreži predslik.

\textbf{Prvi element:}
Iz definicije velja, da je za eno samo celico v mreži nabor ploskev enak naboru vseh predslik.
\textbf{Naslednji element:}
Obstoječi mreži predslik novo celico.
Ploskev iz nabora dodane celice se zvezno veže s ploskvijo
iz obstoječega nabora zveznih ploskev natanko v primeru,
ko se z njo ujema v robu (povezavi med vozliščema).
Temu je tako, ker so indeksi vozlišč in povezav ekvivalentni vrednosti prekrivanj okolic.

\begin{figure}[htb]
\centerline{\psfig{figure=network_array,width=14cm}}
\caption[Mreža polja celic.]{Mreža velikosti \(N_x=3\) in \(N_y=3\) za binarni CA z okolico quad.
Poudarjena je ena zvezna ploskev in njen rob (konfiguracija pripadajoče predslike je izpisana).}
\label{network_array}
\end{figure}

\section{Robni pogoji} 

Pri 1D CA so robni pogoji definirani na dveh koncih,
ki omejujejo končno število celic na neskončni premici.
Če je 1D CA definiran kakor poltrak je robni pogoj samo eden.
Robni pogoj definira katere okolice (vozlišča pri mreži predslik za 1D CA)
in s kakšnimi utežmi so na voljo ob robu.
Lahko si jih predstavljamo tudi kakor vpliv, neskončnega poltraka celic,
ki sega izven roba opazovane konfiguracije.

Pri 2D CA je robni pogoj definiran na sklenjeni poti okoli ploskve opazovane konfiguracije celic.
V mreži predslik za 2D CA povezave med vozlišči definirajo rob ploskve (slika \ref{network_array}).
Na splošno ima vsaka ploskev v mreži svoj rob, robni pogoj določa kako je ta ploskev obravnavana.
Ker uporabna vrednost splošnega robnega pogoja še ni znana,
in bi splošnost izrazito povečala zahtevnost algoritma za iskanje predslik,
so tukaj vsi robovi obravnavani enako. Temu bomo rekli odprt rob,
ker ta ne definira nobenih omejitev, katere zvezne ploskve v mreži predslik
so dovoljene in katere ne.

Obstaja še eden enostaven robni pogoj, ki je definiran za ciklično sklenjena končna CA polja.
Ta tip robnega pogoja tukaj ne bo obravnavan, ker še dodatno poveča kompleksnost algoritmov.

\chapter{Algoritem za štetje in izpis predslik}

Pri 1D CA ima algoritem za štetje predslik linearno \(O(N)\) procesno in pomnilniško zahtevnost.
Posplošeno to pomeni, da se vsaka celica pojavi v izračunu samo enkrat.
Dejansko ima vsak algoritem tudi logaritmično komponento,
saj število bitov potrebnih za zapis števcev raste logaritmično s številom celic.
Algoritem za izpis predslik ima tudi eksponentno maksimalno kompleksnost,
saj maksimalno in povprečno število predslik raste eksponentno
v odvisnosti od števila celic.

Za 2D CA se je izkazalo, da obstajajo problemi, ki niso rešljivi z linearno kompleksnostjo.
Prikazani algoritem ima maksimalno eksponentno kompleksnost
v odvisnosti od posamezne dimenzije \(O(S^{N_x} S^{N_y})\).
Za sedaj je še odprta možnost za obstoj algoritma s kompleksnostjo
med linearno in eksponentno.

Opisani algoritem za štetje predslik razdeli polje celic na vrstice v dimenziji X.
Delitev po stolpcih v dimenziji Y bi bila ekvivalentna,
tako da je to arbitrarna. S stališča procesne zahtevnosti je najbolje izbrati krajšo dimenzijo.
Na podlagi zunanjega robnega pogoja je najprej poiskan nabor predslik za prvo vrstico.
Nabor predslik je izračunan kakor uteži za robove na nasprotni strani od začetne.
Te uteži so uporabljene kakor vhodni robni pogoj za naslednjo vrstico.
Robne uteži izračunane za zadnjo vrstico predstavljajo število vseh predslik.

Algoritem za izpis predslik je nadaljevaje algoritma za štetje.
Starta z znanim številom predslik, ki ga je dalo štetje, in izpisuje predslike
po vrsticah v obratni smeri, kakor je potekalo štetje.

\section{Procesiranje v eni dimenziji}

Procesiranje se začne z eno dimenzionalnim nizom celic (vrstico).
Vsaki celici v nizu pripada lastna mreža predslik, eno dimenzionalnemu nizu celic
posledično pripada povezan niz mrež predslik (slika \ref{algorithm_line} mreža \textbf{1}).
Vsak segment mreže v nizu ima svoj nabor veljavnih okolic,
ki je definiran s tranzicijsko funkcijo (ali pa je posplošeno poljuben nabor).
Na začetku se ploskve okolic sosednjih celic še ne povezujejo v
zvezno ploskev čez celoten niz. Izločiti je potrebno vse ploskve okolic,
ki se ne povezujejo z okolicami svojih sosednjih celic.

Ker se vsaka vrstica povezuje s predhodno in naslednjo vrstico, je potrebno
upoštevati tudi zveznost ploskev na prehodu med vrsticami.
Ta povezava med vrsticami je prerez opazovane ploskve na meji med vrsticama.
Vsaka ploskev je obravnavana posebej in prerez je izražen kakor robni pogoj.
Začetni robni pogoj za vsako vrstico je nabor poti med vozlišči na začetku vrstice.
Vsaka pot je obravnavana posebej (slika \ref{algorithm_line} mreža \textbf{2}, odebeljena pot).

Začetni robni pogoj se aplicira tako, da se izloči iz obravnave vse ploskve,
ki nimajo skupnega roba z robno potjo (slika \ref{algorithm_line}
prehod iz mreže \textbf{1} v mrežo \textbf{2}). Za tem korakom, so vse ploskve definirane
v dveh od štirih vozlišč, do nezveznosti lahko prihaja le še na robu nasprotnem
začetnemu robu.

Problem se reducira iz tri dimenzionalne mreže in procesiranja ploskev v
dvo dimenzionalno mrežo, kjer se procesirajo poti med vozlišči (slika \ref{algorithm_line}
prehod iz mreže \textbf{2} v mrežo \textbf{3}). To je problem, ekvivalenten iskanju predslik
(zvenih poti v grafu) za 1D CA, za kar se uporabi algoritem opisan v \cite{JerasDobnikar2007}.
Rezultat so poti na prerezu med ploskvami (slika \ref{algorithm_line} mreža \textbf{4},
končni robni pogoj je odebeljen).

\begin{figure}[htb]
\centerline{\psfig{figure=algorithm_line,width=14cm}}
\caption[Algoritem procesiranja vrstice.]{Mreža vrstice velikosti \(N_x=3\) za binarni CA z okolico quad.
Nabor okolic/ploskev za posamezno celico je arbitraren, izbran tako, da poudari korake algoritma.}
\label{algorithm_line}
\end{figure}

Po procesiranju nabora vseh začetnih robnih pogojev, nastane nabor vseh končnih robnih pogojev.
Ta nabor se v naslednjem koraku uporabi kakor začetni robni pogoj za naslednjo vrstico.

Nabor vseh možnih poti na meji vrstice raste eksponentno z dolžino vrstice.
Število vseh poti se izračuna iz števila vejitev na vsakem vozlišču in dolžine poti.
Za deljenje po vrsticah v dimenziji X je ta nabor \( |S|^{(M_y-1)^{N_x+1}} \).
Posledično kompleksnost algoritma raste eksponentno z dolžino vrstice \(O(C^{N_x})\).

\section{Procesiranje v drugi dimenziji}

V drugi dimenziji se procesira niz vrstic. Vsaka vrstica se začne in konča
z robnim pogojem, ti robni pogoji so prerezi ploskev v celotni mreži predslik.
Za tem, ko so procesirane vse vrstice, je znan končni rob nabora vseh zveznih
ploskev na celotni mreži predslik. Če je uporabljena Boolova algebra je znan
le obstoj predslik, če pa je uporabljeno množenje in seštevanje,
je na koncu znano tudi število predslik.

\section{Izpis predslik}

Ni nujno, da se vsak vrstični začetni pogoj preslika v nabor končnih pogojev.
Možno je da nobena pot na končnem robu ne zadošča začetnemu pogoju in mreži predslik.
Torej po prejšnjih korakih še ni točno določeno, katere ploskve se združujejo v zvezno
celoto in katere ne. Možne so ploskve, ki prekrivajo polje samo do neke vrstice in ne naprej.

Procesiranje po drugi dimenziji poteka v obratni smeri kakor pri štetju,
začne pri zadnji vrstici in konča pri prvi vrstici (slika \ref{algorithm_list}).
Z vsakim korakom izloča še preostale slepe poti iz mreže predslik.
Hkrati je možno še izpisovati predslike. Že na začetku procesiranja v obratni smeri,
je že znano število vseh predslik, kar omogoča rezervacijo pomnilnika.
Končne robne poti in njihove uteži, se uporabijo za popis tekoče vrstice celic
v predslikah. Z vsakim korakom v obratni smeri se popiše nova vrstica za vsako od preštetih predslik.
Ko pride algoritem, spet do začetne vrstice, so vse predslike popisane.
Hkrati so iz mreže predslik izločene vse slepe poti, ostanejo le še ploskve,
ki tvorijo zvezne ploskve na celotnem polju celic.

\begin{figure}[htb]
\centerline{\psfig{figure=algorithm_list,width=8cm}}
\caption[Algoritem za izpis predslik.]{Potek smeri procesiranja pri algoritmu za izpis predslik.}
\label{algorithm_list}
\end{figure}

Algoritem tukaj ni podrobno opisan, je pa preprosta razširitev algoritma uporabljenega
za 1D CA opisanega v \cite{JerasDobnikar2007}. Za podrobnosti je na voljo izvorna koda v prilogah.

\section{Nezmožnost procesiranja z linearno zahtevnostjo}

Podan je primer, ki kaže zakaj procesiranje z linearno zahtevnostjo ni mogoče.

Cilj raziskovalnega dela za to raziskovalno nalogo je bil poiskati
učinkovit algoritem za iskanje predslik 2D CA. Na podlagi izkušenj z 1D CA
sem optimistično pričakoval, da bo možno problem rešiti v linearnem času.

Algoritem v linearnem času, bi vsako celico obravnaval le enkrat
ali na splošno bi bilo število obravnav majhna konstanta (4 krat,
če se izvaja procesiranje skozi mrežo predslik v 4 smereh/prehodih).
Tak algoritem predpostavlja, da je možno celoten nabor začetnih
robnih pogojev upoštevati hkrati v enem samem prehodu. Po nekaj
poizkusih sem ugotovil da temu ni tako. Vsaj nekatere poti iz nabora je
potrebno upoštevati ločeno.

V podanem primeru (slika \ref{algorithm_issue}) se prvi dve vrstici zaključita
naborom dveh končnih poti \textbf{0110} in \textbf{1111}. Če bi te dve poti
uporabili, hkrati kakor začetni robni pogoj za naslednjo vrstico, bi dobili
enak rezultat kakor, če bi bili del robnega pogoja še poti \textbf{0111} in \textbf{1110}.
To pa zato, ker algoritem, ki poti ne obravnava ločeno ne more vedeti
kje se je pot začela, da bi jo lahko tudi pravilno zaključil.
Posledično linearen algoritem lahko vzame začetek ene od poti in ga
na vozliču skupnem obema potema nadaljuje po drugi poti.
Iz mreže je razvidno, da te dve poti nista preseka neke zvezne ploskve.
Skratka hkratno obravnavanje celotnega nabora robnih pogojev ni možno,
kar pomeni, da je število obravnav neke celice odvisno od števila poti
in posledično od velikosti problema.

Zgoraj opisani algoritem izrecno obravnava vsak robni pogoj iz nabora ločeno.
Je pa videti, da bi bilo možno hkrati obravnavati robove, ki nimajo nobenega skupnega
vozlišča. Najbrž obstajajo tudi druge optimizacije algoritma, ki lahko zmanjšajo
procesno kompleksnost.

\begin{figure}[htb]
\centerline{\psfig{figure=algorithm_issue,width=14cm}}
\caption[Ovira za procesiranje z linearno zahtevnostjo.]{Ovira za procesiranje z linearno zahtevnostjo.}
\label{algorithm_issue}
\end{figure}

\chapter{Primerjava z znanimi algoritmi}

Obstoječi algoritmi za predslike 2D CA se osredotočajo izključno na GoL.
Največ algoritmov je namenjenih iskanju GoE stanj, skratka preverjajo le
obstoj predslik, in jih ne štejejo ali izpisujejo.

\section{Iskanje GoE za GoL}

Conway je leta 1970 predstavil GoL. Že leta 1971 sta Roger Banks in Steve Ward
predstavila prvo GoE stanje velikosti \(9 \times 33\) celic.
Odkritje je bilo objavljeno v \cite{Lifeline3}. Kasneje je Don Woods
\cite{Lifeline3, Lifeline4} s pomočjo računalnika dokazal, da je stanje res GoE.

Woodsov algoritem, tako kakor moj, deluje na vrsticah.
Starta z eno vogalno celico, katere nabor predslik je kar nabor okolic,
ki se preslikajo v stanje celice. V naslednjem koraku se opazuje sosednjo celico v vrstici.
Za vse kombinacije okolic dodane celice in obstoječi nabor predslik se preveri,
če se ujemajo kjer se okolice prekrivajo. Če se ujemajo, se doda sestavljeno predsliko v nabor,
sicer predslika izpade iz nabora. Ko pride algoritem do konca vrstice nadaljuje v naslednji vrstici,
le da je sedaj prekrivanje med naborom predslik in okolico dodane celice drugačno.
Tako algoritem nadaljuje do konca celotne konfiguracije.
Če je nabor predslik prazen, je opazovana konfiguracija GoE.
Nabor predslik in s tem poraba pomnilnika in procesnega časa ostajajo
relativno majhni v primerjavi z naborom vseh stanj.
Temu je tako, ker imajo v praksi tudi deli GoE konfiguracije malo predslik.
Algoritem bi bil za konfiguracije z dosti predslikami veliko bolj pomnilniško in časovno potraten.

Nicolay Beluchenko je poiskal večje število GoE stanj velikosti \(11 \times 11\).
Sicer ne poznam vseh njegovih pristopov, ampak vsaj v enem primeru je uporabljal
podoben algoritem kakor Woods. Startal je s osrednjo celico in dodajal nove celice
v spirali okoli osrednje. Za vrednost celice je uporabil tisto, ki je dala manjši nabor predslik.

Leta 1974 je Duparc \cite{Duparc1972, Duparc1974} razvil drugačen algoritem,
ter z njim poiskal GoE stanja velikosti \(6 \times 122\) in \(6 \times 117\).
Algoritem uporablja teorijo končnih avtomatov in regularnih jezikov, ki je v
osnovi namenjen eno dimenzionalnim sistemom. Duparc ga je razširil
tako, da je celice iz vrstice 2D polja združil v simbole regularnega jezika,
zaporedje več vrstic pa predstavlja besedo.
Duparcov algoritem ne obravnava vseh stanj vrstice enakovredno,
temveč se osredotoča na vrstice, ki zmanjšujejo nabor predslik.
Obravnavanje vseh stanj vrstic bi namreč preseglo pomnilniške sposobnosti
takratne in sedanje strojne opreme že za kratke vrstice.
Dokaže le, da vrstice dolžine 1 ne obstaja stolpec širine 1, ki bi bil GoE stanje.
Originalni članek je v francoščini, tako da lahko algoritem opišem le na podlagi tega, kako ga opisujejo drugi.

V zadnjih letih podoben algoritem uporablja Steven Eker (CSL, SRI International, California, USA).
Dokazal je, da za pravokotne konfiguracije višine 2 in 3 ne obstajajo GoE stanja,
dokaz za konfiguracije višine 4 z danim algoritmom še vedno presega sposobnosti sodobne strojne opreme.
Število stanj avtomata, ki opisuje jezik GoE namreč raste eksponentno z višino.
Elker je poiskal GoE stanja velikosti \(9 \times 11\), \(8 \times 12\) in \(5 \times 83\).
Na žalost raziskovalcu delodajalec prepoveduje objavo rezultatov in podrobnosti, dokler ni opravljen interni pregled.

Drugačen algoritem uporablja Marijn Heule \cite{Hartman2013}.
S sodelavci je zapisal vsa prekrivanja za določeno stanje kakor binarne enačbe.
Te je nato dal v reševanje orodju za reševanje SAT problemov.
Če rešitev ne obstaja, pomeni da je stanje GoE.
Uporabljena je dodatna predpostavka, da bo rešitev zrcalno simetrična v obeh dimenzijah,
kar občutno zmanjša zahtevnost procesiranja.

\section{Iskanje predslik GoL na splošno}

Erlan \cite{Erlan2012} je predstavil igro pri kateri se za dano stanje
GoL išče predslike. To dejansko ni implementacija algoritma za iskanje predslik,
je pa vzpodbudil druge k iskanju takega algoritma.

Spletna stran \url{kaggle.com} je pripravila tekmovanje \cite{kaggle2013},
kjer so morali kandidati reševati problem iskanja predslik. Podali so
nabor stanj za katere je treba poiskati predslike in nabor učnih sekvenc.
Pričakovali so rešitev, ki temelji na strojnem učenju ali optimiziranju,
torej fokus ni bil na eksaktni rešitvi.

Pri iskanju implementacij algoritma, sam našel Atabot \cite{Borah2013} in
Celični kronometer \cite{Duxbury2013}. Cilj teh algoritmov sicer je iskanje
predslik, ampak iskanje ni sistematično in cilj ni nabor vseh možnih predslik.
Oba algoritma se poslužujeta določene hevristike pri iskanju.

\section{Polni algoritmi za štetje in izpis predslik}

Opisani algoritmi za iskanje GoE stanj, na primer Woods,
sicer omogočajo iskanje vseh predslik, ampak to ni njihov glavni namen.
Optimizirani le za GoE stanja, kjer je predslik malo tudi za del konfiguracije.
Predvsem niso optimizirani za splošni primer, kjer je lahko predslik veliko,
posledično so potratni s porabo pomnilnika, saj hranijo celoten nabor predslik,
medtem ko bi bilo bolje hraniti le progresivne razlike med predslikami.

Našel sem le eno aplikacijo, ki je namenjena štetju in izpisu vseh predslik.
Bickford \cite{Bickford2012} prav tako kakor ostali procesira konfiguracijo
po vrsticah, znotraj vrstice pa lahko uporablja različne algoritme (Woods, Duparc).
Bickford opiše tudi algoritem, ki namesto procesiranja po vrsticah združuje predslike
kvadratnih delov konfiguracij. Na žalost poda primerjavo med različnimi algoritmi
le kakor procesni čas za posamezno implementacijo, ne pa tudi bolj splošne
ocene maksimalne in povprečne procesne/pomnilniške zahtevnosti.

\chapter{Sklepne ugotovitve}

Sklepne ugotovitve naj prikažejo oceno o opravljenem delu in povzamejo težave, na katere je naletel kandidat. Kot rezultat dela
lahko navede ideje, ki so nastale med delom, in bi lahko bile predmet novih raziskav.

Primerjava s sorodnimi deli bo s stališča procesne zahtevnosti algoritma in glede na to,
katere znane probleme bo algoritem sposoben rešiti. Nekaj takih problemov, urejenih glede na zahtevnost, je:
\begin{enumerate}[noitemsep,nolistsep]
\item določitev, ali obstajajo predslike za dano trenutno stanje sistema
\item štetje predslik
\item naštevanje konfiguracij predslik
\item jezik vseh stanj brez predslik
\item vprašanje reverzibilnosti sistema
\end{enumerate}

Rešitev problema določitve obstoja predslik si že predstavljam. 
Predvidevam, da bom uspel rešiti še problem preštevanja predslik,
in ker je to manjši korak, tudi njihovo naštevanje.

Preostalih problemov se tokrat ne bom loteval.
Problem jezika stanj brez predslik bi potreboval teorijo 2D formalnega jezika, ki še ne obstaja.
Poleg tega je povezan s problemom reverzibilnosti, ki je na splošno dokazano nerešljiv \cite{Kari1989}.

\newpage

%********************************************

\appendix

%\addcontentsline{toc}{chapter}{\protect Dodatki}

\newpage

\addcontentsline{toc}{chapter}{Seznam slik}
\addtocontents{toc}{\protect\vspace{-2ex}}
\listoffigures

\newpage

\addcontentsline{toc}{chapter}{Seznam tabel}
\listoftables

%\listofalgorithms

%********************************************

\newpage

\bibliographystyle{slplainurl}
\addcontentsline{toc}{chapter}{Literatura}
\label{stran_literatura}
\bibliography{magisterij} 

\end{document}
