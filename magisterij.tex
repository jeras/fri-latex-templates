%*****************************************************************
%   Vzorec za pisanje diplomskega dela,
%   ki vsebuje navodila za izdelavo diplomskega dela
%
%   UNIVERZA V LJUBLJANI
%   Fakulteta za računalništvo in informatiko
%
%   Pripravila: Peter.Peer@fri.uni-lj.si
%               Franc.Solina@fri.uni-lj.si
%*****************************************************************

\documentclass[12pt,a4paper,openany,twoside]{book}

%Uporabljeni paketi
\usepackage[utf8]{inputenc}
\usepackage{cmap}
\usepackage{type1ec}
\usepackage[T1]{fontenc}
\usepackage{graphicx,epsfig}
\usepackage[slovene]{babel}
\usepackage{cite}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{url}
\usepackage[pdftex,colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black]{hyperref}
\usepackage[top=2cm, bottom=3cm, inner=3cm, outer=2cm]{geometry}
%\usepackage[backend=bibtex]{biblatex}

%\addbibresource{magisterij.bib}

%Nastavitev glave in repa strani
\pagestyle{myheadings}

% stil odstavkov
\setlength{\parindent}{0cm}
\setlength{\parskip}{5mm plus2mm minus2mm}

\input{cc}

%********************************************
% kratice, simboli
\newcommand{\abbrlabel}[1]{\makebox[3cm][l]{\textbf{#1}\ \dotfill}}
\newenvironment{abbreviations}{\begin{list}{}{\renewcommand{\makelabel}{\abbrlabel}}}{\end{list}}
%********************************************

\begin{document}

%********************************************
% platnica
\thispagestyle{empty} 
\begin{center}
             {\large UNIVERZA V LJUBLJANI\\
                     FAKULTETA ZA RAČUNALNIŠTVO IN INFORMATIKO\\}
\vspace{3cm} {\large Iztok Jeras}\\
\vspace{2cm} {\large \textbf{Predslike 2D celičnih avtomatov}}\\
\vspace{2cm} {MAGISTERSKO DELO\\ NA UNIVERZITETNEM ŠTUDIJU}\\
\vfill       {\Large Ljubljana, 2016}
\end{center}
\newpage
\ \thispagestyle{empty}
\newpage
%********************************************

%********************************************
% stran 1 med uvodnimi listi
\thispagestyle{empty} 
\begin{center}
             {\large UNIVERZA V LJUBLJANI\\
                     FAKULTETA ZA RAČUNALNIŠTVO IN INFORMATIKO\\}
\vspace{3cm} {\large Iztok Jeras}\\
\vspace{2cm} {\large \textbf{Predslike 2D celičnih avtomatov}}\\
\vspace{2cm} {MAGISTERSKO DELO\\ NA UNIVERZITETNEM ŠTUDIJU}\\
\vspace{2cm} {\Large Mentor: prof. dr. Branko Šter}
\vfill       {\Large Ljubljana, 2016}
\end{center}
\newpage
\ \thispagestyle{empty}
\newpage
%********************************************

%********************************************
% stran 7 med uvodnimi listi

\chapter*{Zahvala}

\thispagestyle{empty}

Zahvaljujem se prof. dr. Andreju Dobnikarju za pomoč pri pisanju člankov
o algoritmih za štetje in izpis predslik pri eno dimenzionalnih celičnih avtomatih.

\newpage

%********************************************
% stran 8 med uvodnimi listi je prazna pri dvostranskem tiskanju
\ \thispagestyle{empty}

\newpage

\renewcommand\thepage{} 
\tableofcontents 
\renewcommand\thepage{\arabic{page}}

\thispagestyle{empty}

%********************************************

\chapter*{Seznam uporabljenih kratic in simbolov}

\thispagestyle{empty}

% simboli

\begin{abbreviations}
\item[1D] eno dimenzionalen
\item[2D] dvo dimenzionalen
\item[3D] tro dimenzionalen
\item[CA] celični avtomat
\item[GoL] Conway's Game of Life (Conwayeva igra življenja)
\item[GoE] Garden of Eden (stanje brez predslik)
\item[trid] okolica CA sestevljena iz treh celic
\item[quad] okolica CA sestevljena iz štirih celic \(M_x=M_y=2\)

\item[\(C\)] poljubna konstanta
\item[\(S\)] množica nabora stanj celice
\item[\(|S|\)] število možnih stanj celice
\item[\(c\)] stanje posamezne celice (celoštevilska vrednost)
\item[\(c_{x,y}\)] vrednost celice na položaju \([x,y]\) znotraj 2D polja celic
\item[\(c^t\)] vrednost celice v sedanjosti
\item[\(c^{t+1}\)] vrednost celice v prihodnosti (eden korak)
\item[\(N_x\)] velikost 2D polja celic v dimenziji X
\item[\(N_y\)] velikost 2D polja celic v dimenziji Y
\item[\(N\)] število celic v 2D polju
\item[\(M_x\)] velikost 2D okolice celice v dimenziji X
\item[\(M_y\)] velikost 2D okolice celice v dimenziji Y
\item[\(m\)] število celic v 2D okolici
\item[\(n\)] stanje okolice posamezne celice (celoštevilska vrednost)
\item[\(n_{x,y}\)] vrednost okolice celice na položaju \([x,y]\) znotraj 2D polja celic
\item[\(n^{t-1}\)] vrednost okolice celice v preteklosti (eden korak)
\item[\(n^t\)] vrednost okolice celice v sedanjosti
\item[\(f\)] tranzicijska funkcija, ki definira časovno evolucijo avtomata
\item[\(f^{-1}\)] obratna tranzicijska funkcija
\item[\(o_x\)] prekrivanje okolic v dimenziji X
\item[\(o_y\)] prekrivanje okolic v dimenziji Y
\item[\(o_{xy}\)] prekrivanje okolic v diagonalni smeri
\end{abbreviations}

%\cleardoublepage

\clearpage{\pagestyle{empty}\cleardoublepage}

%********************************************
%zacno se glavni listi, ki so numerirani z arabskimi stevilkami

\setcounter{page}{1}
\pagenumbering{arabic}

\chapter*{Povzetek}

\addcontentsline{toc}{chapter}{Povzetek}

Medtem, ko je računanje predslik 1D celičnih avtomatov dobro raziskan in
podrobno dokumentiran problem, je to področje pri 2D celičnih avtomatih manj
raziskano. To magistrsko delo poizkuša aplicirati metode razvite za 1D avtomate
na 2D problem. Prikazan je algoritem, ki omogoča štetje in izpis predslik.
Razvit je bil s pomočjo grafičnega modela, mreže predslik, 
ki omogoča uporabo teorije grafov pri izračunih in dokazih.

\vspace{1.3cm}
\noindent
{\large \bf Ključne besede:}

\vspace{0.5cm}
\noindent
celični avtomati, predslike, procesna zahtevnost, reverzibilnost, rajski vrt, Conwayeva igra življenja, trid, quad


\chapter*{Abstract}

\addcontentsline{toc}{chapter}{Abstract}

While computing preimages of 1D cellular automata is a well researched and
documented problem, for 2D cellular automata there is less research available.
This masters thesis attempts to apply methods developed for 1D automata to the
2D problem. An algorithm is shown, which can count and list preimages.
It was developed with the help of a graphical representation, the preimage network,
which enables using graph theory for computation and proofs.

\vspace{1.3cm}
\noindent
{\large \bf Key words:}

\vspace{0.5cm}
\noindent
cellular automata, preimages, ataviser, computational complexity, reversibility, Garden of Eden, Conway's Game of Life, trid, quad


%********************************************

\chapter{Uvod}

\section{CA kakor model vesolja}

Ker lahko vsak univerzalen sistem modelira vsak drug univerzalen sistem, lahko predpostavimo,
da lahko z univerzalnimi CA modeliramo vesolje. Samo modeliranje vesolja
je še izven našega dosega, poizkuša pa se vsaj približati teorijo CA in teoretično fiziko.
S strani informacijske teorije in termodinamike je predvsem zanimiv model gravitacije
kakor entropijske sile (Entropic gravity \cite{Verlinde2010}), ki predpostavlja, da je
3D vesolje projekcija procesov, ki se odvijajo na 2D ploskvi. Z druge strani pa CA tudi omogočajo
opazovanje abstraktnega kopiranja informacij (replikacija) in evolucije \cite{Salzberg2004}.
Oba sta pomembna informacijska pojava v našem vesolju.

\section{Informacijska dinamika}

Informacijsko dinamiko CA se najpogosteje opisuje samo kakor reverzibilno ali ireverzibilno,
obstaja tudi nekaj člankov, ki opazujejo entropijo sistema.
Pogosto je tudi opazovanje dinamike delcev pri GoL in elementarnem pravilu 110.
Ne obstaja pa še splošna teorija dinamike informacij v CA.
V svojem članku \cite{JerasDobnikar2007} in prispevkih na konferencah \cite{DBLP:conf/iccS/JerasD06, DBLP:conf/automata/Jeras08, Jeras2008-pyca},
sem grafično upodobil predslike trenutnega stanja za 1D problem.
Iz upodobitve je videti, da se ponekod izgubi več informacije kakor drugod,
kar kaže na možnost izpeljave kvalitativne in kvantitativne teorije dinamike informacij.
Na žalost se ta možnost še ni udejanila. Podobno je možno grafično upodobiti predslike 2D CA,
ter iz grafov sklepati o izgubi informacij v 2D CA.

\section{Problem predslik 2D CA}

Najbolje teoretično raziskan 2D CA je GoL (Game of Life ali slovensko igra življenja).
Ogromno truda je bilo vloženega v raziskovanje delcev in njihove dinamike. S pomočjo
osnovnih gradnikov, je mogoče skonstruirati kompleksnejše sisteme, med katerimi so
najzanimivejši turingov stroj \cite{Rendell2001} in univerzalni konstruktor \cite{Greene2013}.

Delci so dejansko atraktorji v razvoju CA na končni periodični mreži (thorus).
Pri 1D CA se algoritmi za iskanje predslik uporabljajo za določitev atraktorjevega korita \cite{Wuensche1992}.
V vsakem CA, ki ni lokalno injektiven se pojavljajo stanja brez predslik imenovana GoE
(Garden of Eden ali rajski vrt) \cite{Moore1962, Myhill1963}.
Pomensko so GoE nasprotje delcev, saj se nahajajo kar
najdlje od atraktorja na robu korita. GoE stanja tudi privlačijo raziskovalce,
čeprav v nekoliko manjši meri kakor delci.

Največ raziskav s področja predslik GoL je bilo opravljenih ravno s ciljem iskanja GoE stanj.
S stališča algoritma za štetje predslik je GoE stanje tako, ki nima nobene predslike.
Algoritem za štetje predslik je možno pretvoriti v manj zahteven algoritem za preverjanje ali je stanje GoE,
tako da se operacije nad celimi števili pretvori v logične operacije nad Boolovimi stanji.

\section{Algoritmi za iskanje predslik}

Raziskave algoritmov sem se lotil s predpostavko, da je možno opraviti štetje z zahtevnostjo,
ki je linearno odvisna od velikosti problema \( O(N) \)  (\(N\) je število opazovanih celic).
Čeprav je to možno pri 1D problemu, se izkaže, da 2D problem ni tako preprost.
Predstavljeni so primeri iz katerih je razvidno,
da algoritem z linearno zahtevnostjo ne more pravilno opisati vseh situacij.
Zahtevnost opisanega algoritma sicer raste eksponentno z velikostjo ene
od dimenzij CA polja \( O(C^{N_x}) \), je pa možno, da obstaja algoritem z nižjo kompleksnostjo.

Pomembno vlogo pri razvoju opisanega algoritma ima mreža predslik.
To je grafična upodobitev problema, katere cilj je lažje razumevanje problema in rešitve.
Osnova za oblikovanje mreže predslik so De Bruijn-ovi diagrami.
Paulina Léon in Genaro Martínez \cite{PaulinaGenaro2016}
poizkušata aplicirati De Bruijn-ove diagrame na 2D CA,
doslej je bilo to orodje uporabljeno le na 1D problemih.
Točneje, opazujeta dva CA:'Game of Life' in 'Diffusion rule',
s poudarkom na opazovanju stabilnih delcev.
Sam uporabljam De Bruijn-ovi diagrame nekoliko drugače,
in jih tudi drugače grafično upodabljam.
Posamezen De Bruijn-ov diagram postane mreža predslik ene celice.
Mreže posameznih celic se nato povezujejo,
tako da na koncu opisujejo celotno polje celic.

Doslej sem že razvil napredne algoritme za izračun predslik 1D CA \cite{JerasDobnikar2007}.
Skozi zgodovino so taki algoritmi napredovali, tako da je padala njihova
procesna zahtevnost in opisna/implementacijska zahtevnost.
\begin{enumerate}[noitemsep,nolistsep]
 \item 'brute force' algoritmi \( O(C^N) \)
 \item improvizirani algoritmi
 \item zasnove matematičnega modela
 \item optimalni algoritmi \( O(N) \)
\end{enumerate}
Iskanje predslik 2D CA je trenutno nekje med improvizacijo in matematičnim modelom.

Opisan algoritem na koncu primerjam z ostalimi doslej znanimi algoritmi.
Čeprav s stališča procesne zahtevnosti ne prinaša želenega napredka,
pa to, da temelji na pregledni grafični upodobitvi, daje upanje,
da bojo razne optimizacije razvidne bodočim raziskovalcem.

Celični avtomat GoL je definiran z Moorovo okolico velikosti \(3 \times 3\).
Tako velika okolica ima z \(9\) celicami \(2^9=512\) možnih stanj,
zaradi česar so ilustracije mreže predslik velike in nepregledne.
Splošno je znana manjša von Neumannova okolica velikosti \(3 \times 3\) v obliki križa iz \(5\) celic.
Z \(2^5=32\) stanji bi bile ilustracije bolj pregledne, ampak obstajajo tudi okolice z manj celicami.
Toffoli \cite{Toffoli2008} je leta 2008 spodbudil raziskovalce k iskanju univerzalnosti za CA
z okolicama trid (tri celice na heksagonalnem polju) in quad (štiri celice na kvadratnem polju).
Powley \cite{Powley2008} hitro dokaže obstoj univerzalnega avtomata z okolico trid,
tako da ustvari avtomat, ki lahko s pomočjo določenega začetnega stanja
simulira poljubni 1D elementarni celični avtomat, na primer pravilo 110.
Sam sem obe okolici poznal že prej. Njuna najboljša lastnost je majhen nabor stanj okolice,
\(2^4=16\) za quad in \(2^3=8\) za trid. Za primere je bil uporabljen quad,
saj so diagrami na kvadratni mreži bolj enostavni in pregledni, kakor diagrami na heksagonalni mreži.

Algoritem je implementiran kot računalniški program v jeziku C \cite{Jeras2016-algirithm}.
Knjižnica GMP \footnote{The GNU Multiple Precision Arithmetic Library \url{https://gmplib.org/}}
je uporabljena za zapis celih števil večjih od 64 bitov.
Poleg samega algoritma za štetje in izpis predslik sem pripravil tudi
orodje za simulacijo binarnega CA z okolico quad \cite{Jeras2016-quad}
in orodje za prikaz poljubne mreže predslik \cite{Jeras2016-network}.
Obe orodji se lahko zažene kar v internetnem brskalniku.

V slikah je uporabljena izometrična projekcija,
saj je za potrebe analize osnovnemu 2D polju dodana tretja dimenzija,
ki opisuje prostor predslik (mreža predslik).

\chapter{Definicija 2D CA}

Predstavljena definicija 2D CA je enostavna in manj formalna
v primerjavi z definicijo 1D CA v podobnih prispevkih.
Bolj formalna definicija ni potrebna, saj se opisani problemi pri 2D CA,
še ne povezujejo z drugimi vejami matematike toliko kakor pri 1D CA.

Osnovni element 2D CA je celica, kakor del polja celic.
Vsaka celica ima diskretno vrednost \(c\) iz nabora stanj celice \(S\).
Stanja so običajno kar oštevilčena.

\begin{equation}
c \in S
\quad \textrm{in} \quad
S = \{ 0, 1, \dots, {\lvert S \rvert} -1 \}
\end{equation}

Mreža polja je lahko pravokotna, šestkotna ali celo kvazikristalna, tukaj se
bomo omejili na pravokotno mrežo. Na splošno je velikost polja lahko neskončna,
bolj običajna pa so končna polja definira kakor pravokotnik velikosti \(N_x \times N_y\).
Skupno število celic v končnem polju je \(N=N_x \cdot N_y\).

Prihodnje stanje neke celice \(c_{x,y}\) na položaju \((x,y)\)
je odvisno od trenutnega stanja pripadajoče okolice \(n_{x,y}\) (slika \ref{neighborhood}).
Tudi pri obliki okolice se bom omejil na pravokotnik velikosti \(M_x \times M_y\).
Število celic v okolici je \(m=M_x \cdot M_y\).
Na voljo je \({\lvert S \rvert}^m\) možnih okolic.

\begin{equation}
n \in S^m
\quad \textrm{in} \quad
S^m = \{ 0, 1, \dots, {\lvert S \rvert}^m -1 \}
\end{equation}

Prostorski odnos med okolico in celico v prihodnjem stanju avtomata, ki jo ta okolica določa,
ni podrobno definiran. Običajno se smatra, da je celica v sredini okolice, ampak za opisani algoritem to ni
nujno pomembno. Moja implementacija algoritma celice, okolice in samo polje indeksira tako,
da je začetna ali referenčna celica v spodnjem levem kotu.

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood,width=16cm}}
\caption[Velikost okolice.]{Celica \(c_{x,y}\) in pripadajoča okolica \(n_{x,y}\) z dimenzijama \(M_x=M_y=3\).}
\label{neighborhood}
\end{figure}

Preslikava sedanje okolice \(n_{x,y}^{t}\) v prihodnjo istoležno celico \(c_{x,y}^{t+1}\) je definiran
s tranzicijsko funkcijo \(f\), ki vsaki vrednosti okolice pripiše vrednost celice.

\begin{equation}
c_{x,y}^{t+1} = f(n_{x,y}^{t})
\end{equation}

Za potrebe iskanja predslik je zanimiva obratna funkcija \(f^{-1}\), ki ob
podanem stanju trenutne celice \(c_{x,y}^{t}\) vrne množico okolic,
ki se preslikajo v to vrednost.

\begin{equation}
f^{-1}(c^{t}) = \{ n^{t-1} \in S^m \ \arrowvert \ f(n^{t-1}) = c^{t} \}
\end{equation}

Dodaten pogoj za predslike polja celic je, da se morajo okolice sosednjih celic
ujemati povsod, kjer se prekrivajo.

Tranzicijsko funkcijo je možno definirati s pravilom.
Pravilo \(r\) je celo število v \(S\)-iškem številskem sestavu,
kjer so cifre zaporedje vrednosti celic za vsako od \(|S|^m\) možnih okolic.
Vseh pravil je na voljo \(|S|^{|S|^m}\).
\begin{equation}
r = \sum_{n=0}^{n=|S|^m-1} |S|^n \cdot f(n)
\end{equation}
\begin{equation}
r \in \{0, 1, \dots |S|^{|S|^m}-1\}
\end{equation}

Podana konstrukcija mreže predslik in algoritem za izračun predslik omogočata uporabo
bolj splošne definicije. Za vsako celico je lahko definiran lasten nabor predslik \( n^{t-1} \in S^m \),
ki je neodvisen od stanja celice. Ta posplošitev je uporabljena za konstrukcijo umetnih
mrež predslik, ki poudarjajo konkretne probleme povezane s kompleksnostjo algoritma.

Za dano polje celic velikosti \(N_x \times N_y\) in z odprtimi robovi,
je možno izračunati prihodnje stanje polja velikosti \((N_x-(M_x-1)) \times (N_y-(M_y-1))\).
V primeru, če so robovi polja ciklično zaprti (polje v obliki thorusa),
je pa polje prihodnjega stanja enako veliko kakor polje sedanjega.
Podobno velja za računanje predslik, za sedanje polje velikosti \(N_x \times N_y\)
je za odprte robove velikost polja predslik \((N_x+(M_x-1)) \times (N_y+(M_y-1))\).
Za ciklične robove pa sta velikosti enaki.

\chapter{Konstrukcija mreže predslik}

Mreža predslik je grafični konstrukt, ki omogoča upodobitev posameznih pojmov
iz definicije CA, kakor ločene grafične elemente. Odnosi med
temi elementi definirajo pravila na katerih se gradijo algoritmi za iskanje
predslik.

\section{De Bruijnov diagram}

Osnovni element grafične upodobitve je De Bruijinov diagram. V osnovi ta obravnava
ciklične premike končnih zaporedij simbolov, ter njihovo prekrivanje. Vozlišča v
diagramu so vsa možna končna zaporedja, povezave med njimi pa definirajo, kako se
ta zaporedja prekrivajo med seboj.

Pri 1D CA se problem neposredno preslika na De Bruijinov graf. McIntosh
in njegova skupina uporabljajo za analizo te De Bruijinove grafe neposredno. Sam sem pa
razvil modificiran graf, kjer so vozlišča podvojena, in gredo poti vedno od originala
proti dvojniku (slika \ref{de_bruijn_diagram}).
To omogoča veriženje grafov, in razširitev osnovnega De Bruijinovega grafa.
Medtem ko osnovni De Bruijinov graf opisuje okolico ene celice, verižen graf opisuje verigo celic.

\begin{figure}[htb]
\centerline{\psfig{figure=de_bruijn_diagram,width=12cm}}
\caption[De Bruijinov graf, pravilo 110.]{De Bruijinov graf za elementarni 1D CA, pravilo 110.}
\label{de_bruijn_diagram}
\end{figure}

Za potrebe opisa 2D celičnih avtomatov, je bila elementom
De Bruijinovega grafa dodana nova dimenzija. Povezave med vozliči se spremenijo
v ploskve, in vozlišča se spremenijo v robove ploskev.
Elementi celičnega avtomata, ki se preslikajo v graf so:
\begin{itemize}[noitemsep,nolistsep]
\item nabor vseh možnih \textbf{okolic} celice postane nabor vseh \textbf{ploskev} (slika \ref{neighborhood_surfaces})
\item nabor \textbf{prekrivanj okolic v smeri 2D dimenzij} (slika \ref{overlap_dimension_quad}) postane nabor \textbf{povezav}
\item nabor \textbf{prekrivanj okolic v diagonalni smeri} (slika \ref{overlap_diagonal_quad}) postane nabor \textbf{vozlišč}
\end{itemize}

Elemente celičnega avtomata, kakor okolice in prekrivanja okolic je potrebno indeksirati,
tako da se lahko vsakemu elementu pripiše unikatna števna vrednost.
Vsaki okolici je pripisana zaporedna vrednost, ki je konstruirana kakor \(m\) mestno število
v \(S\)-iškem številskem sistemu (za podane primere dvojiški).
Cifre si sledijo od spodaj levo do zgoraj desno znotraj okolice
(sliki \ref{neighborhood_index_moore} in \ref{neighborhood_index_quad}).

\begin{equation}
n = \sum_{\substack{x=0 \\ y=0}}^{\substack{x=M_x-1 \\ y=M_y-1}} |S|^{y M_x + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
n \in \{0, 1, \dots, |S|^{M_x M_y}-1\}
\end{equation}

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood_index_moore,width=12cm}}
\caption[Indeksiranje okolice \(3 \times 3\).]{Indeksiranje okolice celice z dimenzijama \(M_x=M_y=3\).}
\label{neighborhood_index_moore}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood_index_quad,width=10cm}}
\caption[Indeksiranje okolice \(2 \times 2\).]{Indeksiranje okolice celice z dimenzijama \(M_x=M_y=2\).}
\label{neighborhood_index_quad}
\end{figure}

Celice se v smeri dimenzije X prekrivajo za ploskev velikosti \((M_x-1) \times M_y\) (sliki \ref{overlap_dimension_moore} in \ref{overlap_dimension_quad}).
To ob indeksiranju da nabor:
\begin{equation}
o_{x^-} = \sum_{\substack{x=0 \\ y=0}}^{\substack{x=M_x-2 \\ y=M_y-1}} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_{x^+} = \sum_{\substack{x=1 \\ y=0}}^{\substack{x=M_x-1 \\ y=M_y-1}} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_x \in \{0, 1, \dots, |S|^{(M_x-1)M_y}-1\}
\end{equation}

Celice se v smeri dimenzije Y prekrivajo za ploskev velikosti \(M_x \times (M_y-1)\) (sliki \ref{overlap_dimension_moore} in \ref{overlap_dimension_quad}).
To ob indeksiranju da nabor:
\begin{equation}
o_{y^-} = \sum_{\substack{x=0 \\ y=0}}^{\substack{x=M_x-1 \\ y=M_y-2}} |S|^{y M_x + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_{y^+} = \sum_{\substack{x=0 \\ y=1}}^{\substack{x=M_x-1 \\ y=M_y-1}} |S|^{y M_x + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_y \in \{0, 1, \dots, |S|^{M_x(M_y-1)}-1\}
\end{equation}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_dimension_moore,width=8cm}}
\caption[Prekrivaje okolic \(3 \times 3\) v smeri dimenzij X in Y.]
{Prekrivanje okolic sosednjih celic v smeri dimenzij X in Y, za velikost okolice \(M_x=M_y=3\).
Okolice se prekrivajo v 6 celicah od 9.}
\label{overlap_dimension_moore}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_dimension_quad,width=8cm}}
\caption[Prekrivaje okolic \(2 \times 2\) v smeri dimenzij X in Y.]
{Prekrivanje okolic sosednjih celic v smeri dimenzij X in Y, za velikost okolice \(M_x=M_y=2\).
Okolice se prekrivajo v 2 celicah od 4.}
\label{overlap_dimension_quad}
\end{figure}

Celice se v diagonalni smeri prekrivajo za ploskev velikosti \((M_x-1) \times (M_y-1)\) (sliki \ref{overlap_diagonal_moore} in \ref{overlap_diagonal_quad}).
To ob indeksiranju da nabor:
\begin{equation}
o_{{x^-}{y^-}} = \sum_{\substack{x=0 \\ y=0}}^{\substack{x=M_x-2 \\ y=M_y-2}} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_{{x^-}{y^+}} = \sum_{\substack{x=0 \\ y=1}}^{\substack{x=M_x-2 \\ y=M_y-1}} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_{{x^+}{y^-}} = \sum_{\substack{x=1 \\ y=0}}^{\substack{x=M_x-1 \\ y=M_y-2}} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_{{x^+}{y^+}} = \sum_{\substack{x=1 \\ y=1}}^{\substack{x=M_x-1 \\ y=M_y-1}} |S|^{y (M_x-1) + x} \cdot c_{x,y}
\end{equation}
\begin{equation}
o_{xy} \in \{0, 1, \dots, |S|^{(M_x-1)(M_y-1)}-1\}
\end{equation}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_diagonal_moore,width=10cm}}
\caption[Prekrivanje okolic \(3 \times 3\) - diagonalno.]
{Prekrivanje okolic sosednjih celic v diagonalni smeri, za velikost okolice \(M_x=M_y=3\).
Okolice se prekrivajo v 4 celicah od 9.}
\label{overlap_diagonal_moore}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=overlap_diagonal_quad,width=8cm}}
\caption[Prekrivanje okolic \(2 \times 2\) - diagonalno.]
{Prekrivanje okolic sosednjih celic v diagonalni smeri, za velikost okolice \(M_x=M_y=2\).
Okolice se prekrivajo v eni celici od 4.}
\label{overlap_diagonal_quad}
\end{figure}

Nastali graf (slika \ref{network_single}) ima poleg vozlišč in povezav med njimi tudi ploskve.
Ploskve bi v teoriji grafov opisali kakor zanke v grafu, z dodano omejitvijo,
da mora vsako vozlišče ali povezava v zanki pripadati drugemu prekrivanju okolic.

\begin{figure}[htb]
\centerline{\psfig{figure=network_single,width=5cm}}
\caption[Mreža ene celice.]{Mreža ene celice za binarni CA z okolico quad \(M_x=M_y=2\).}
\label{network_single}
\end{figure}

\begin{figure}[htb]
\centerline{\psfig{figure=neighborhood_surfaces,width=16cm}}
\caption[Nabor ploskev.]{Nabor ploskev za vseh 16 možnih vrednosti okolic za binarni CA z okolico quad \(M_x=M_y=2\).}
\label{neighborhood_surfaces}
\end{figure}

\section{Mreža}

Diagrame, ki opisujejo preteklost posamezne celice, je možno sestaviti v mrežo,
ki opisuje polje več celic. Nabor predslik celotnega polja je ekvivalenten naboru
vseh \textit{zveznih} ploskev, ki prekrivajo celotno polje in, ki jih je možno sestaviti iz
naborov ploskev diagramov posameznih celic.

Preslikava iz zvezne ploskve v mreži predslik v konfiguracijo polja celic predslike je enolična.
Najlažje je razumeti preslikavo za okolico velikosti \(3 \times 3\),
od vsakega odseka ploskve za posamezno celico se vzame centralno celico,
na koncu pa se doda še za eno celico širok rob okoli celotne ploskve.

Podani primeri uporabljajo binarni CA s quad okolico.
Za ta CA je velikost diagonalnega prekrivanja okolic ena sama celica (slika \ref{overlap_diagonal_quad}),
posledično ima nabor vozlišč le dve vrednosti, ki neposredno predstavljajo
vrednosti celic v predsliki (slika \ref{network_array}).
Nabor okolic/ploskev pa obsega 16 kombinacij (slika \ref{neighborhood_surfaces}).

Razširitev diagrama ene celice v mrežo lahko dokažemo z indukcijo.
Dokazati želimo, da je neka konfiguracija celic predslika dane sedanjosti
\textit{če in samo če} je ta ekvivalentna zvezni ploskvi v mreži predslik.

\textbf{Prvi element:}
Iz definicije velja, da je za eno samo celico v mreži nabor ploskev enak naboru vseh predslik.
\textbf{Naslednji element:}
Obstoječi mreži predslik dodamo novo celico.
Ploskev iz nabora dodane celice se zvezno veže s ploskvijo
iz obstoječega nabora zveznih ploskev natanko v primeru,
ko se z njo ujema v robu (vozliščema in povezavi med njima).
Temu je tako, ker so indeksi vozlišč in povezav ekvivalentni vrednosti prekrivanj okolic.

\begin{figure}[htb]
\centerline{\psfig{figure=network_array,width=14cm}}
\caption[Mreža polja celic.]{Mreža velikosti \(N_x=3\) in \(N_y=3\) za binarni CA z okolico quad.
Poudarjena je ena zvezna ploskev in njen zvezen rob. Konfiguracija pripadajoče predslike je izpisana.}
\label{network_array}
\end{figure}

\section{Robni pogoji} 

Pri 1D CA so robni pogoji definirani na dveh koncih,
ki omejujejo končno število celic na neskončni premici.
Če je 1D CA definiran kakor poltrak je robni pogoj samo eden.
Robni pogoj definira katere okolice (vozlišča pri mreži predslik za 1D CA)
in s kakšnimi utežmi so na voljo ob robu.
Lahko si jih predstavljamo tudi kakor vpliv, neskončnega poltraka celic,
ki sega izven roba opazovane konfiguracije.

Pri 2D CA je robni pogoj definiran kakor utež sklenjene poti okoli ploskve opazovane konfiguracije celic.
V mreži predslik za 2D CA povezave med vozlišči definirajo rob ploskve (slika \ref{network_array}).
Na splošno ima vsaka zvezna ploskev v mreži svoj rob, robni pogoj določa, kako je ta ploskev obravnavana.
Ker uporabna vrednost splošnega robnega pogoja še ni znana,
in bi splošnost izrazito povečala zahtevnost algoritma za iskanje predslik,
so tukaj vsi robovi obravnavani enako. Temu bomo rekli odprti rob,
ker ta ne definira nobenih omejitev, katere zvezne ploskve v mreži predslik
so dovoljene in katere ne.

Obstaja še eden enostaven robni pogoj, ki je definiran za ciklično sklenjena končna CA polja.
Ta tip robnega pogoja tukaj ne bo obravnavan, ker še dodatno poveča kompleksnost algoritmov.
Potrebno bi bilo namreč opraviti celoten postopek iskanja predslik za vsak začetni rob posebej.
Zvezna ploskev je predslika v cikličnem polju le, če se njen začetni in končni rob ujemata.
Pojma začetnega in končnega roba sta opisana v poglavju o algoritmu.

\chapter{Algoritem za štetje in izpis predslik}

Pri 1D CA ima algoritem za štetje predslik linearno \(O(N)\) procesno in pomnilniško zahtevnost.
Posplošeno to pomeni, da se vsaka celica pojavi v izračunu samo enkrat.
Dejansko ima vsak algoritem tudi logaritmično komponento,
saj število bitov potrebnih za zapis števcev raste logaritmično s številom celic.
Algoritem za izpis predslik ima neizogibno eksponentno kompleksnost \(O(C^N)\),
saj maksimalno in povprečno število predslik raste eksponentno
v odvisnosti od števila celic.

Za 2D CA se je izkazalo, da obstajajo problemi, ki niso rešljivi z linearno kompleksnostjo.
Prikazani algoritem ima maksimalno eksponentno kompleksnost
v odvisnosti od posamezne dimenzije \(O(S^{N_x} S^{N_y})\).
Za sedaj je še odprta možnost za obstoj algoritma s polinomsko kompleksnostjo
med linearno in eksponentno.

Opisani algoritem za štetje predslik razdeli polje celic na vrstice v dimenziji X.
Delitev po stolpcih v dimenziji Y bi bila ekvivalentna, tako da je to arbitrarna odločitev.
S stališča procesne zahtevnosti je najbolje izbrati krajšo dimenzijo.
Na podlagi zunanjega robnega pogoja je najprej poiskan nabor predslik za prvo vrstico.
Nabor predslik je izračunan kakor uteži za robove na nasprotni strani od začetne.
seznam robov in njihove uteži so uporabljeni kakor vhodni robni pogoji za naslednjo vrstico.
Robne uteži izračunane za zadnjo vrstico predstavljajo število vseh predslik.

Algoritem za izpis predslik je nadaljevaje algoritma za štetje.
Starta z znanim številom predslik, ki ga je dalo štetje, in izpisuje predslike
po vrsticah v obratni smeri, kakor je potekalo štetje, od zadnje do prve vrstice.
Pridobljen seznam predslik je sortiran. Smer sortiranja je odvisna od smeri procesiranja.
Smer procesiranja je možno po potrebi spremeniti.

\section{Procesiranje v eni dimenziji}

Procesiranje se začne z eno dimenzionalnim nizom celic (vrstico).
Vsaki celici v nizu pripada lastna mreža predslik, eno dimenzionalnemu nizu celic
posledično pripada povezan niz mrež predslik (slika \ref{algorithm_line} mreža \textbf{1}).
Vsak segment mreže v nizu ima svoj nabor veljavnih okolic,
ki je definiran s tranzicijsko funkcijo (ali pa je posplošeno poljuben nabor).
Na začetku se ploskve okolic sosednjih celic še ne povezujejo v
zvezno ploskev čez celoten niz. Izločiti je potrebno vse ploskve okolic,
ki se ne povezujejo z okolicami svojih sosednjih celic.

Ker se vsaka vrstica povezuje s predhodno in naslednjo vrstico, je potrebno
upoštevati tudi zveznost ploskev na prehodu med vrsticami.
Ta povezava med vrsticami je prerez opazovane ploskve na meji med vrsticama.
Vsaka ploskev je obravnavana posebej in prerez je izražen kakor robni pogoj.
Začetni robni pogoj za vsako vrstico je nabor poti med vozlišči na začetku vrstice.
Vsaka pot je obravnavana posebej (slika \ref{algorithm_line} mreža \textbf{2}, odebeljena pot).
Začetni robni pogoj je ekvivalenten nizu prekrivanja okolic \(o_{y^-}\).

Začetni robni pogoj se aplicira tako, da se izloči iz obravnave vse ploskve,
ki nimajo skupnega roba z robno potjo (slika \ref{algorithm_line}
prehod iz mreže \textbf{1} v mrežo \textbf{2}). Za tem korakom, so vse ploskve definirane
v dveh od štirih vozlišč, do nezveznosti lahko prihaja le še na robu nasprotnem
začetnemu robu.

Problem se reducira iz tri dimenzionalne mreže in procesiranja ploskev v
dvo dimenzionalno mrežo, kjer se procesirajo poti med vozlišči (slika \ref{algorithm_line}
prehod iz mreže \textbf{2} v mrežo \textbf{3}). To je problem, ekvivalenten iskanju predslik
(zvenih poti v grafu) za 1D CA, za kar se uporabi algoritem opisan v \cite{JerasDobnikar2007}.
Rezultat so poti na prerezu med ploskvami (slika \ref{algorithm_line} mreža \textbf{4},
končni robni pogoj je odebeljen).
Končni robni pogoj je ekvivalenten nizu prekrivanja okolic \(o_{y^+}\).

\begin{figure}[htb]
\centerline{\psfig{figure=algorithm_line,width=14cm}}
\caption[Algoritem procesiranja vrstice.]{Mreža vrstice velikosti \(N_x=3\) za binarni CA z okolico quad.
Nabor okolic/ploskev za posamezno celico je arbitraren, izbran tako, da poudari korake algoritma.}
\label{algorithm_line}
\end{figure}

Po procesiranju nabora vseh začetnih robnih pogojev, nastane nabor vseh končnih robnih pogojev.
Ta nabor se v naslednjem koraku uporabi kakor začetni robni pogoj za naslednjo vrstico.

Nabor vseh možnih poti na meji vrstice raste eksponentno z dolžino vrstice.
Število vseh poti se izračuna iz števila celic, ki se prekrivajo med okolicama dveh vrstic.
Za deljenje po vrsticah v dimenziji X je ta nabor \( |S|^{(M_y-1)(M_x-1+N_x)} \).
Posledično kompleksnost algoritma raste eksponentno z dolžino vrstice \(O(C^{N_x})\).

\section{Procesiranje v drugi dimenziji}

V drugi dimenziji se procesira zaporedje vrstic od prve do zadnje (slika \ref{algorithm_list}).
Vsaka vrstica se začne in konča z robnim pogojem,
ti robni pogoji so prerezi ploskev v celotni mreži predslik.
Vsako vrstico je potrebno v drugi dimenziji procesirati le enkrat, kar pomeni,
da je procesna zahtevnost linearno odvisna od števila vrstic \(O(N_y)\).

Vsakemu robnemu pogoju je pripisana utež. Začetni robovi za prvo vrstico imajo pripisano utež \(w=1\).
Na splošno se lahko več začetnih robov preslika v isti končni rob ene vrstice.
Utež pripisana končnemu robu dane vrstice, je vsota uteži vseh začetnih robnih pogojev, ki se preslikajo vanj.
Utež tako predstavlja število vseh predslik za dano in prejšnje vrstice, ki se končajo z opazovanim robom.
Robovi s katerimi se ne konča nobena od predslik dobijo utež \(w=0\).

Za tem, ko so procesirane vse vrstice, je znan končni rob nabora vseh zveznih ploskev na celotni mreži predslik.
Vsota uteži vseh končnih robov daje število predslik celotne mreže.

Z uporabo Boolove algebre \(w \in {0, 1}\) namesto operacij množenja in seštevanja,
je možno poenostaviti iskanje predslik samo na njihov obstoj za opazovani robni pogoj.

\section{Izpis predslik}

Ni nujno, da se vsak vrstični začetni pogoj preslika v nabor končnih pogojev.
Možno je da nobena pot na končnem robu ne zadošča začetnemu pogoju in mreži predslik.
Torej po prejšnjih korakih še ni točno določeno, katere ploskve se združujejo v zvezno
celoto in katere ne. Možne so ploskve, ki prekrivajo polje samo do neke vrstice in ne naprej.

Procesiranje po drugi dimenziji poteka v obratni smeri kakor pri štetju,
začne pri zadnji vrstici in konča pri prvi vrstici (slika \ref{algorithm_list}).
Z vsakim korakom se izloča še preostale slepe poti iz mreže predslik.
Za vsako vrstico je potrebno ponovno rešiti 1D problem,
le da sta začetni in končni rob zamenjana.
Začetni rob je zaporedje prekrivanja okolic \(o_{y^+}\))
in končni rob je zaporedje prekrivanja okolic \(o_{y^-}\)).

Hkrati je možno še izpisovati predslike. Že na začetku procesiranja v obratni smeri,
je znano število vseh predslik, kar omogoča rezervacijo pomnilnika in inicializacijo seznama predslik.
Končne robne poti in njihove uteži, se uporabijo za popis tekoče vrstice celic v predslikah.
Indeks poti (določeno zaporedje prekrivajočih okolic) da vrednost celic v predsliki,
uteži izračunane v smeri štetja pa dajo število predslik,
ki jih je potrebno popisati z dano vrednostjo celic.

Z vsakim korakom v obratni smeri se popiše nova vrstica za vsako od preštetih predslik.
Ko pride algoritem, spet do začetne vrstice, so vse predslike popisane.
Hkrati so iz mreže predslik izločene vse slepe poti, ostanejo le še ploskve,
ki tvorijo zvezne ploskve na celotnem polju celic.

\begin{figure}[htb]
\centerline{\psfig{figure=algorithm_list,width=8cm}}
\caption[Algoritem za izpis predslik.]{Potek smeri procesiranja pri algoritmu za štetje in izpis predslik.}
\label{algorithm_list}
\end{figure}

Algoritem tukaj ni podrobno opisan, je pa preprosta razširitev algoritma uporabljenega
za 1D CA opisanega v \cite{JerasDobnikar2007}. Za podrobnosti je na voljo izvorna koda \cite{Jeras2016-algirithm}.

\section{Nezmožnost procesiranja z linearno zahtevnostjo}

Podan je primer, ki kaže zakaj procesiranje z linearno zahtevnostjo ni mogoče.

Cilj raziskovalnega dela za to raziskovalno nalogo je bil poiskati
učinkovit algoritem za iskanje predslik 2D CA. Na podlagi izkušenj z 1D CA
sem optimistično pričakoval, da bo možno problem rešiti v linearnem času.

Algoritem v linearnem času, bi vsako celico obravnaval le enkrat
ali na splošno bi bilo število obravnav majhna konstanta (4 krat,
če se izvaja procesiranje skozi mrežo predslik v 4 smereh/prehodih).
Tak algoritem predpostavlja, da je možno celoten nabor začetnih
robnih pogojev upoštevati hkrati v enem samem prehodu.
V koraku \textbf{2} na pri procesiranju vrstice (sliki \ref{algorithm_line})
bi se izločilo le ploskve, ki ne ustrezajo nobenemu od začetnih robnih pogojev.
Po nekaj poizkusih sem ugotovil, da tak algoritem ne deluje pravilno.
Vsaj nekatere poti iz nabora je potrebno upoštevati ločeno.

V podanem primeru (slika \ref{algorithm_issue}) se prvi dve vrstici zaključita z
naborom dveh končnih poti \textbf{0110} in \textbf{1111}. Če bi te dve poti
uporabili hkrati, kakor začetni robni pogoj za naslednjo vrstico, bi dobili
enak rezultat kakor, če bi bili del robnega pogoja tudi poti \textbf{0111} in \textbf{1110}.
To pa zato, ker algoritem, ki poti ne obravnava ločeno, ne more vedeti,
kje se je pot začela, da bi jo lahko tudi pravilno zaključil.
Posledično linearen algoritem lahko vzame začetek ene od poti in ga
na vozliču skupnem obema potema nadaljuje po drugi poti.
Iz mreže je razvidno, da te dve poti nista preseka neke zvezne ploskve.
Skratka hkratno obravnavanje celotnega nabora robnih pogojev ni možno,
kar pomeni, da je število obravnav neke celice odvisno od števila poti
in posledično od eksponenta števila celic v vrstici.

Možno je, da obstajajo drugačne optimizacije algoritma, ki lahko zmanjšajo procesno kompleksnost.

\begin{figure}[htb]
\centerline{\psfig{figure=algorithm_issue,width=14cm}}
\caption[Ovira za procesiranje z linearno zahtevnostjo.]
{Ovira za procesiranje z linearno zahtevnostjo.
Veljavni robni pogoj je odebeljen, neveljavni pa črtkan.}
\label{algorithm_issue}
\end{figure}

\chapter{Primerjava z znanimi algoritmi}

Obstoječi algoritmi za predslike 2D CA se osredotočajo izključno na GoL.
Največ algoritmov je namenjenih iskanju GoE stanj, skratka preverjajo le
obstoj predslik in jih ne štejejo ali izpisujejo. Tukaj opisani algoritem
je zamišljen bolj univerzalno za poljuben 2D CA. Vendar univerzalnost v
praksi ni ravno pomembna, saj izven raziskovalcev GoL ni dosti zanimanja
za teoretične probleme, kakor je iskanje predslik.

\section{Iskanje GoE za GoL}

Conway je leta 1970 predstavil GoL. Že leta 1971 sta Roger Banks in Steve Ward
predstavila prvo GoE stanje velikosti \(9 \times 33\) celic.
Odkritje je bilo objavljeno v \cite{Lifeline3}. Kasneje je Don Woods
\cite{Lifeline3, Lifeline4} s pomočjo računalnika dokazal, da je stanje res GoE.

Woodsov algoritem, tako kakor moj, deluje na vrsticah.
Starta z eno vogalno celico, katere nabor predslik je kar nabor okolic,
ki se preslikajo v stanje celice. V naslednjem koraku se opazuje sosednjo celico v vrstici.
Za vse kombinacije okolic dodane celice in obstoječi nabor predslik se preveri,
če se ujemajo, kjer se okolice prekrivajo. Če se ujemajo, se doda sestavljeno predsliko v nabor,
sicer predslika izpade iz nabora. Ko pride algoritem do konca vrstice, nadaljuje v naslednji vrstici,
le da je sedaj prekrivanje med naborom predslik in okolico dodane celice drugačno (več sosednjih celic namesto ene).
Tako algoritem nadaljuje do konca celotne konfiguracije.
Če je končni nabor predslik prazen, je opazovana konfiguracija GoE.
Nabor predslik in s tem poraba pomnilnika in procesnega časa ostajajo
relativno majhni v primerjavi z naborom vseh stanj.
Temu je tako, ker imajo v praksi tudi deli GoE konfiguracije malo predslik.
Algoritem bi bil za konfiguracije z dosti predslikami veliko bolj pomnilniško in časovno potraten.

Nicolay Beluchenko je poiskal večje število GoE stanj velikosti \(11 \times 11\).
Sicer ne poznam vseh njegovih pristopov, ampak vsaj v enem primeru je uporabljal
podoben algoritem kakor Woods. Startal je z osrednjo celico in dodajal nove celice
v spirali okoli osrednje. Za vrednost dodane celice je uporabil tisto, ki je dala manjši nabor predslik.
Algoritem zaključi, ko z novo dodano celico ni več možno tvoriti predslik.

Leta 1974 je Duparc \cite{Duparc1972, Duparc1974} razvil drugačen algoritem,
ter z njim poiskal GoE stanja velikosti \(6 \times 122\) in \(6 \times 117\).
Algoritem uporablja teorijo končnih avtomatov in regularnih jezikov, ki je v
osnovi namenjena 1D sistemom.
Duparc je celice iz vrstice 2D polja združil v simbole regularnega jezika,
zaporedje več vrstic pa predstavlja besedo.
Duparcov algoritem ne obravnava vseh stanj vrstice enakovredno,
temveč se osredotoča na vrstice, ki zmanjšujejo nabor predslik.
Obravnavanje vseh stanj vrstic bi namreč preseglo pomnilniške sposobnosti
takratne in sedanje strojne opreme že za kratke vrstice.
Dokaže le, da za vrstice dolžine 1 ne obstaja stolpec, ki bi bil GoE stanje.
Originalni članek je v francoščini, tako da lahko algoritem opišem le na podlagi tega, kako ga opisujejo drugi.

V zadnjih letih podoben algoritem uporablja Steven Eker (CSL, SRI International, California, USA).
Dokazal je, da za pravokotne konfiguracije višine 2 in 3 ne obstajajo GoE stanja,
dokaz za konfiguracije višine 4 z danim algoritmom še vedno presega sposobnosti sodobne strojne opreme.
Število stanj avtomata, ki opisuje jezik GoE namreč raste eksponentno z višino.
Elker je poiskal GoE stanja velikosti \(9 \times 11\), \(8 \times 12\) in \(5 \times 83\).
Na žalost raziskovalcu delodajalec prepoveduje objavo rezultatov in podrobnosti, dokler ni opravljen interni pregled.
Tako imamo za sedaj na voljo le zgoraj navedene podatke.

Drugačen algoritem uporablja Marijn Heule \cite{Hartman2013}.
S sodelavci je zapisal vsa prekrivanja za določeno stanje kakor binarne enačbe.
Te je nato predal orodju za reševanje SAT problemov.
Če rešitev ne obstaja, pomeni da je stanje GoE.
Uporabljena je dodatna predpostavka, da bo rešitev zrcalno simetrična v obeh dimenzijah,
kar občutno zmanjša velikost problema.
Algoritem je še dodatno optimiziran za iskanje GoE stanj in
omogoča pregled večjega števila podobnih stanj.
Ob spremembi vrednosti ene same celice omogoča uporabo delnih rezultatov prejšnjega izračuna.
SAT metode ne poznam dobro, teko da ne morem primerjati procesne zahtevnosti.

\section{Iskanje predslik GoL na splošno}

Erlan \cite{Erlan2012} je predstavil igro, pri kateri se za dano stanje
GoL išče predslike. To dejansko ni implementacija algoritma za iskanje predslik,
je pa vzpodbudil druge k iskanju takega algoritma.

Spletna stran \url{kaggle.com} je pripravila tekmovanje \cite{kaggle2013},
kjer so morali kandidati reševati problem iskanja predslik. Podali so
nabor stanj, za katere je treba poiskati predslike, in nabor učnih sekvenc.
Pričakovali so rešitev, ki temelji na strojnem učenju ali optimiziranju,
torej fokus ni bil na eksaktni rešitvi.

Pri iskanju implementacij algoritma, sam našel Atabot \cite{Borah2013},
Celični kronometer \cite{Duxbury2013} in SAT baziran program \cite{Pigorsch2015}.
Cilj teh algoritmov sicer je iskanje predslik, ampak iskanje ni sistematično
in cilj ni nabor vseh možnih predslik.
Algoritmi se tudi poslužujejo določene hevristike pri iskanju.

\section{Polni algoritmi za štetje in izpis predslik}

Opisani algoritmi za iskanje GoE stanj, na primer Woods,
sicer omogočajo iskanje vseh predslik, ampak to ni njihov glavni namen.
Optimizirani le za GoE stanja, kjer je predslik malo tudi za del GoE konfiguracije.
Predvsem niso optimizirani za splošen primer, kjer je lahko predslik veliko,
posledično so potratni s porabo pomnilnika.
Morda bi bilo možno optimizirati porabo pomnilnika,
tako da bi algoritem hranil le tekoče razlike med predslikami, namesto da jih hrani v celoti.

Našel sem le eno aplikacijo, ki je namenjena štetju in izpisu vseh predslik.
Bickford \cite{Bickford2012} prav tako kakor ostali procesira konfiguracijo
po vrsticah, znotraj vrstice pa lahko uporablja različne algoritme (Woods, Duparc).
Bickford opiše tudi algoritem, ki namesto procesiranja po vrsticah združuje predslike
kvadratnih podsklopov konfiguracij. Na žalost poda primerjavo med različnimi algoritmi
le kakor procesni čas za posamezno implementacijo, ne pa tudi bolj splošne
ocene maksimalne in povprečne procesne/pomnilniške zahtevnosti.

Našel sem še aplikacijo napisano v jeziku APL \cite{ionreq2013}.
Dokumentacija te aplikacije ni dovolj jasna, da bi bilo očitno, kaj točno počne.
Iz primera pa sklepam, da je sposobna poiskati vse predslike.

\chapter{Sklepne ugotovitve}

Probleme povezane z iskanjem predslik lahko delimo v nivoje gleda na zahtevnost:
\begin{enumerate}[noitemsep,nolistsep]
\item določitev, ali obstajajo predslike za dano trenutno stanje sistema
\item štetje predslik za dano trenutno stanje sistema
\item naštevanje konfiguracij predslik
\item vprašanje reverzibilnosti sistema
\item jezik vseh GoE stanj
\end{enumerate}

V magistrskem delu opišem algoritem, ki rešuje prve tri probleme.
Preostala problema sta si sorodna.
Problem reverzibilnosti je na splošno dokazano nerešljiv \cite{Kari1989}.
Problem jezika GoE stanj je za 1D preprosto rešljiv, za 2D pa je
verjetno podobno kakor vprašanje reverzibilnosti nerešljiv.

\section{Analiza 2D CA s pomočjo končnih avtomatov}

Problem jezika stanj brez predslik bi potreboval teorijo 2D formalnega jezika, ki še ne obstaja.
Kljub temu je možno zastaviti probleme, ki se jih da preslikati v končni avtomat.
Na primer, če obravnavamo vrstice kakor simbole jezika, lahko sestavimo končni avtomat.
Simboli (stanja vrstic) definirajo prehode med stanji končnega avtomata. Stanja avtomata pa
so vsi možni nabori robov vrstice. Pomembna je le prisotnost roba, ne pa tudi utež.
Poln nabor vsebuje vse možne robove, prazen nabor pa ne vsebuje nobenega roba.
Vsako zaporedje vrstic (simbolov), ki v avtomatu pelje iz polnega v prazno stanje, je GoE konfiguracija.
Zanke v takem avtomatu pa so sorodne delcem.

Opisan pristop postane nepraktičen že za kratke vrstice.
Število vseh možnih robov raste eksponentno z dolžino vrstice \(N_x\).
To število \(|S|^{(M_y-1)(M_x-1+N_x)}\) je enako vsem načinom,
na katere se lahko okolici dveh vrstic prekrivata.
Stanja avtomata pa so vsi možni nabori robov.
Nabor lahko opišemo kakor binarni niz, kjer vsak bit pomeni
prisotnost ali odsotnost enega od robov.
Vseh stanj končnega avtomata je tako \(2^{ |S|^{(M_y-1)(M_x-1+N_x)} }\).
Število stanj avtomata postane neobvladljivo že za kratke vrstice.

Najkrajša GoE beseda znotraj regularnega jezika GoE stanj, je tista,
ki po najkrajši poti in brez zank pripelje iz polnega v prazen nabor.
Pri 1D CA se je izkazalo, da je dolžina najkrajše GoE besede povezana s kompleksnostjo
prostorsko-časovnih vzorcev, ki se pojavljajo pri danem pravilu.
Podobno so verjetno tudi pri 2D CA GoE konfiguracije večje pri pravilih,
ki omogočajo kompleksno dinamiko delcev. Verjetno bi bilo možno to izkoristiti
za iskanje zanimivih pravil v okolici quad.

\section{Izboljšave podanega algoritma}

Implementacijo algoritma je možno izboljšati, tako da zahtevnost
ne raste tako hitro z velikostjo problema.
Za sedaj vidim samo rešitev, ki se osredotoča na povprečno zahtevnost, namesto na maksimalno zahtevnost.
Na primer, sedaj algoritem rezervira pomnilnik za uteži vseh možnih robov,
dovolj pa bi bilo, če bi bil rezerviran pomnilnik samo za robove z utežjo večjo od nič.
Sploh pri iskanju GoE stanj, je robov malo v primerjavi z vsemi možnimi.
Tak pristop bi dal dosti manjšo porabo pomnilnika,
in verjetno tudi znižal čas procesiranja.

Morda bi bilo možno vnaprej določiti zgornjo mejo števila ne ničelnih robov.
To bi omogočalo zgodnjo oceno, če je izračun za dan problem izvedljiv.
Na primer, če bi v vrstičnem procesiranju obravnavali vse začetne robove hkrati
namesto vsakega posebej, bi dobili prevelik nabor končnih robov.
Tak nabor bi vedno vseboval vse pravilne končne robove, in še nekaj napačnih.
Ampak skupno število bilo lahko občutno manjše od polnega nabora.
To število bi lahko uporabili za oceno porabe pomnilnika in časa.
Na ta način bi bilo možno reševati probleme, ki so na meji tega,
kar zmore sodobna strojna oprema.

Samo implementacijo algoritma je tudi možno optimizirati.
Univerzalnost algoritma, predvsem univerzalnost velikosti okolice
prispeva dosti režijskih stroškov. Če bi bil algoritem specializiran
samo za quad ali GoL, bi se lahko izognil precej operacijam.
Podobno velja za nabor stanj. Za binarne CA je možno optimizirati
operacije, ki pretvarjajo 2D nize celic v cela števila in obratno.
Binarne podatke je možno kompaktno pakirati v pomnilnik.
Mogoče je tudi uporabiti logične operacije nad celo besedo celic,
namesto procesiranja vsake celice posebej.

Procesiranje v algoritmu poteka v gnezdenih zankah in v znanem vrstnem redu.
Le manjši del dostopov do pomnilnika je naključen.
Zaporednost podatkov že sama po sebi omogoča dobro optimizacijo dostopa do predpomnilnika,
tako da na tem področju ni dosti očitnih optimizacij.

%********************************************

\appendix

\chapter{De Bruijinov diagram za GoL}

Slika \ref{network_single_moore} prikazuje del De Bruijinovega diagrama za GoL.
Graf s 16 vozlišči in 64 povezavami je očitno preveč kompleksen, da bi bil primeren za razlago algoritma.
Število vseh možnih okolic (ploskev v diagramu) pa je celo 512.

\begin{figure}[htb]
\centerline{\psfig{figure=network_single_moore,width=13cm}}
\caption[Mreža ene celice za GoL.]{Mreža ene celice za binarni CA z Moorovo okolico \(M_x=M_y=3\).}
\label{network_single_moore}
\end{figure}

\chapter{Primer delovanja algoritma za CA z okolico quad}

V naslednjem primeru je prikazano štetje in iskanje predslik
za binarni CA (celica ima lahko \(2\) stanji) z okolico velikosti \(2 \times 2\)
in pravilom številka \verb|0x725A|.

Konfiguracija je majhna velikosti \(2 \times 2\) shranjena v datoteki \verb|test_2x2.cas|.
Uporabil bi večjo konfiguracijo a na žalost ne poznam pravila,
ki bi za večjo konfiguracijo dal majhno število predslik.

Uporabljen je program \cite{Jeras2016-algirithm} z verzijo \verb|v1|.

\begin{verbatim}
$ ./ca2d_preimages 2 2 2 0x725a 2 2 test_2x2.cas
CA parameters:
  sts  : 2
  ngb  : siz={2,2}, a=4, n=16
  ovl-y: siz={1,2}, a=2, n=4
  ovl-x: siz={2,1}, a=2, n=4
  rem-y: siz={1,2}, a=2, n=4
  rem-x: siz={2,1}, a=2, n=4
  ver  : siz={1,1}, a=1, n=2
  shf-y: siz={1,1}, a=1, n=2
  shf-x: siz={1,1}, a=1, n=2

RULE = 0x725a
  tab [0] = [[0,0],[0,0]] = 0
  tab [1] = [[1,0],[0,0]] = 1
  tab [2] = [[0,1],[0,0]] = 0
  tab [3] = [[1,1],[0,0]] = 1
  tab [4] = [[0,0],[1,0]] = 1
  tab [5] = [[1,0],[1,0]] = 0
  tab [6] = [[0,1],[1,0]] = 1
  tab [7] = [[1,1],[1,0]] = 0
  tab [8] = [[0,0],[0,1]] = 0
  tab [9] = [[1,0],[0,1]] = 1
  tab [A] = [[0,1],[0,1]] = 0
  tab [B] = [[1,1],[0,1]] = 0
  tab [C] = [[0,0],[1,1]] = 1
  tab [D] = [[1,0],[1,1]] = 1
  tab [E] = [[0,1],[1,1]] = 1
  tab [F] = [[1,1],[1,1]] = 0

CA configuration siz [y↓,x→] = [2,2]:
 1 0
 0 1

NETWORK: edge weights from forward/backward direction,
         summed preimages
net [dy=0][y=0] = [1 1 1 1 1 1 1 1 ]
net [dy=0][y=1] = [2 2 0 2 3 3 0 1 ]
net [dy=0][y=2] = [0 3 5 0 0 2 7 2 ]  cnt [0] = 19
net [dy=1][y=0] = [0 4 4 0 0 4 5 2 ]  cnt [1] = 19
net [dy=1][y=1] = [2 0 3 4 2 0 1 1 ]
net [dy=1][y=2] = [1 1 1 1 1 1 1 1 ]

preimage i=0:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 0
 0 0 0
 0 1 0

preimage i=1:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 0
 0 0 0
 0 1 1

preimage i=2:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 0
 0 0 1
 0 1 0

preimage i=3:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 0
 0 0 1
 0 1 1

preimage i=4:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 0
 1 1 0
 1 0 0

preimage i=5:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 0
 1 1 0
 1 0 1

preimage i=6:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 0
 1 1 0
 0 1 1

preimage i=7:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 0
 1 1 0
 1 1 1

preimage i=8:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 1
 0 0 0
 0 1 0

preimage i=9:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 1
 0 0 0
 0 1 1

preimage i=10:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 1
 0 0 1
 0 1 0

preimage i=11:  CA configuration siz [y↓,x→] = [3,3]:
 1 0 1
 0 0 1
 0 1 1

preimage i=12:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 1
 1 1 0
 1 0 0

preimage i=13:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 1
 1 1 0
 1 0 1

preimage i=14:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 1
 1 1 0
 0 1 1

preimage i=15:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 1
 1 1 0
 1 1 1

preimage i=16:  CA configuration siz [y↓,x→] = [3,3]:
 0 1 1
 1 1 1
 1 0 0

preimage i=17:  CA configuration siz [y↓,x→] = [3,3]:
 1 1 1
 0 0 1
 0 1 0

preimage i=18:  CA configuration siz [y↓,x→] = [3,3]:
 1 1 1
 0 0 1
 0 1 1
\end{verbatim}

\newpage

%********************************************

\appendix

%\addcontentsline{toc}{chapter}{\protect Dodatki}

\newpage
\addcontentsline{toc}{chapter}{Seznam slik}
\addtocontents{toc}{\protect\vspace{-2ex}}
\listoffigures

%\newpage
%\addcontentsline{toc}{chapter}{Seznam tabel}
%\listoftables

%\listofalgorithms

%********************************************

\newpage

\bibliographystyle{slplainurl}
%\bibliographystyle{apsrevSLO}
\addcontentsline{toc}{chapter}{Literatura}
\label{stran_literatura}
\bibliography{magisterij} 

%\printbibliography

\end{document}
